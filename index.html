<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三國演義：無限戰役 (完美路徑版)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap');

        :root {
            --bg-color: #f4e4bc;
            --panel-color: #3e2723;
            --text-color: #f4e4bc;
            --accent-color: #d32f2f;
            
            /* Faction Colors */
            --shu-color: #2e7d32;
            --wei-color: #1565c0;
            --wu-color: #c62828;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #1a100e;
            font-family: 'Noto Serif TC', serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            color: #333;
            user-select: none;
        }

        #game-wrapper {
            position: relative;
            width: 1200px;
            height: 700px;
            background-color: var(--bg-color);
            border: 4px solid var(--panel-color);
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            display: flex;
            flex-direction: row;
        }

        /* --- Screens --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        /* Menu Styles */
        .faction-select {
            display: flex;
            gap: 20px;
            margin-top: 40px;
        }

        .faction-card {
            width: 200px;
            height: 320px;
            border: 4px solid #555;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
        }

        .faction-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
        }

        .faction-shu { border-color: var(--shu-color); }
        .faction-shu:hover { background: linear-gradient(to bottom, rgba(46,125,50,0.2), transparent); }
        
        .faction-wei { border-color: var(--wei-color); }
        .faction-wei:hover { background: linear-gradient(to bottom, rgba(21,101,192,0.2), transparent); }

        .faction-wu { border-color: var(--wu-color); }
        .faction-wu:hover { background: linear-gradient(to bottom, rgba(198,40,40,0.2), transparent); }

        .faction-symbol { font-size: 80px; margin-bottom: 20px; }
        .faction-name { font-size: 32px; font-weight: bold; margin-bottom: 10px; }
        .faction-desc { font-size: 14px; text-align: center; padding: 0 15px; color: #ccc; line-height: 1.5; }

        /* Level Complete Screen */
        #level-screen h2 { font-size: 40px; color: #ffd700; margin-bottom: 10px; }
        #level-screen p { font-size: 18px; color: #eee; margin-bottom: 30px; }
        .next-btn {
            background: linear-gradient(#4caf50, #2e7d32);
            border: 2px solid #a5d6a7;
            padding: 15px 40px;
            font-size: 24px;
            color: white;
            cursor: pointer;
            border-radius: 8px;
            font-family: 'Noto Serif TC', serif;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .next-btn:hover { transform: scale(1.05); }

        /* Game Layout */
        #game-canvas {
            flex-grow: 1;
            background-color: #dccbba;
            cursor: crosshair;
        }

        #ui-sidebar {
            width: 320px;
            background-color: var(--panel-color);
            color: var(--text-color);
            padding: 15px;
            display: flex;
            flex-direction: column;
            border-left: 4px solid #1a100e;
            box-sizing: border-box;
            z-index: 10;
        }

        h1 { margin: 0 0 10px 0; font-size: 22px; text-align: center; border-bottom: 2px solid var(--text-color); padding-bottom: 10px; color: #ffb74d; }
        
        .header-info { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; color: #bdbdbd; }

        .stats-panel {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 4px;
        }
        .stat-item { display: flex; flex-direction: column; align-items: center; font-size: 13px; }
        .stat-value { font-size: 18px; font-weight: bold; color: #ffb74d; margin-top: 4px; }

        .tower-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 15px;
        }

        .tower-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #4e342e;
            border: 2px solid #6d4c41;
            padding: 6px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.1s;
        }
        .tower-btn:hover { background-color: #5d4037; border-color: #ffb74d; }
        .tower-btn.selected { background-color: #1b5e20; border-color: #66bb6a; box-shadow: 0 0 8px #66bb6a; }
        .tower-btn.disabled { opacity: 0.5; filter: grayscale(1); cursor: not-allowed; }
        .tower-icon-display { font-size: 20px; margin-bottom: 2px; }
        .tower-name { font-size: 14px; font-weight: bold; }
        .tower-cost { font-size: 12px; color: #ffcc80; }

        /* Detail Panel */
        #detail-panel {
            background: rgba(0,0,0,0.3);
            border: 1px solid #8d6e63;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 13px;
            min-height: 120px;
        }
        .detail-title { color: #ffb74d; font-weight: bold; font-size: 15px; margin-bottom: 5px; border-bottom: 1px solid #5d4037; padding-bottom: 3px; display: flex; justify-content: space-between; }
        .detail-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .detail-desc { margin-top: 8px; color: #e0e0e0; font-style: italic; line-height: 1.4; }

        /* Upgrade Actions */
        .action-row { display: flex; gap: 5px; margin-top: auto; margin-bottom: 10px; }
        .btn-mini { flex: 1; padding: 8px; border: none; border-radius: 4px; cursor: pointer; color: white; font-weight: bold; font-family: inherit; }
        .btn-upg { background-color: #2e7d32; }
        .btn-upg:disabled { background-color: #1b5e20; opacity: 0.5; }
        .btn-sell { background-color: #c62828; }

        /* Main Button */
        #start-btn {
            width: 100%; padding: 12px; font-family: inherit; font-size: 18px; font-weight: bold;
            background-color: var(--accent-color); color: white; border: none; cursor: pointer;
            border-radius: 4px; box-shadow: 0 4px #b71c1c; margin-top: auto;
        }
        #start-btn:active { transform: translateY(4px); box-shadow: none; }
        #start-btn:disabled { background-color: #757575; box-shadow: none; }

        .back-btn {
            position: absolute; top: 10px; left: 10px;
            background: transparent; border: 1px solid #ffb74d; color: #ffb74d;
            padding: 5px 15px; cursor: pointer; font-family: inherit; z-index: 200;
        }
        .back-btn:hover { background: rgba(255, 183, 77, 0.2); }

    </style>
</head>
<body>

    <div id="game-wrapper">
        <!-- MENU SCREEN -->
        <div id="menu-screen" class="screen">
            <h1 style="font-size: 48px; border: none; margin-bottom: 10px;">三國：群雄割據</h1>
            <p style="color: #bbb; margin-bottom: 40px; font-size: 18px;">選擇陣營 · 隨機戰場 · 完美路徑</p>
            
            <div class="faction-select">
                <div class="faction-card faction-shu" onclick="startGame('shu')">
                    <div class="faction-symbol" style="color: var(--shu-color)">蜀</div>
                    <div class="faction-name">蜀漢</div>
                    <div class="faction-desc">山道險要<br>武將：五虎上將<br>特性：防守/控制</div>
                </div>
                
                <div class="faction-card faction-wei" onclick="startGame('wei')">
                    <div class="faction-symbol" style="color: var(--wei-color)">魏</div>
                    <div class="faction-name">曹魏</div>
                    <div class="faction-desc">城池堅固<br>武將：五子良將<br>特性：爆發/範圍</div>
                </div>

                <div class="faction-card faction-wu" onclick="startGame('wu')">
                    <div class="faction-symbol" style="color: var(--wu-color)">吳</div>
                    <div class="faction-name">東吳</div>
                    <div class="faction-desc">水寨連環<br>武將：江東虎臣<br>特性：灼燒/攻速</div>
                </div>
            </div>
        </div>

        <!-- LEVEL COMPLETE SCREEN -->
        <div id="level-screen" class="screen hidden">
            <h2 id="level-title">大獲全勝</h2>
            <p id="level-desc">敵軍敗退，我軍士氣大振！</p>
            <p id="level-reward" style="font-size: 16px; color: #66bb6a; margin-top: -10px; margin-bottom: 20px;"></p>
            <button class="next-btn" onclick="nextLevel()">進軍下一關 (保留庫銀)</button>
        </div>

        <!-- GAME OVER SCREEN -->
        <div id="end-screen" class="screen hidden">
            <h2 id="end-title" style="font-size: 40px; color: #ef5350;">城池失守</h2>
            <p id="end-desc" style="font-size: 18px; margin: 20px 0;">...</p>
            <button onclick="location.reload()" style="padding: 10px 30px; font-size: 18px; cursor: pointer;">返回標題</button>
        </div>

        <!-- GAME PLAY AREA -->
        <canvas id="game-canvas" width="880" height="700"></canvas>
        
        <aside id="ui-sidebar">
            <div class="header-info">
                <span id="faction-label">陣營</span>
                <span id="map-label">關卡: 1</span>
            </div>
            <h1 id="faction-title">地圖名</h1>
            
            <div class="stats-panel">
                <div class="stat-item"><span>波次</span><span id="wave-display" class="stat-value">1/5</span></div>
                <div class="stat-item"><span>耐久</span><span id="lives-display" class="stat-value" style="color: #ef5350;">20</span></div>
                <div class="stat-item"><span>庫銀</span><span id="gold-display" class="stat-value" style="color: #ffd700;">150</span></div>
            </div>

            <div id="tower-grid" class="tower-grid"></div>

            <div id="detail-panel">
                <div style="text-align: center; color: #757575; padding-top: 40px;">
                    選擇武將查看詳情
                </div>
            </div>

            <div id="action-area" class="action-row hidden">
                <button id="btn-upgrade" class="btn-mini btn-upg" onclick="actionUpgrade()">
                    晉升 <span id="cost-upg">(100)</span>
                </button>
                <button id="btn-sell" class="btn-mini btn-sell" onclick="actionSell()">
                    撤退 <span id="cost-sell">(50)</span>
                </button>
            </div>

            <button id="start-btn" onclick="startNextWave()">進攻開始</button>
        </aside>

        <button class="back-btn" onclick="location.reload()">退出戰役</button>
    </div>

    <script>
        // --- Data Definitions ---

        const ARCHETYPES = {
            'archer': { type: 'single', range: 180, damage: 15, cooldown: 25, speed: 12, nameType: '神射', desc: '射程遠，攻速中等' },
            'fast':   { type: 'single', range: 130, damage: 8, cooldown: 10, speed: 15, nameType: '突擊', desc: '攻速極快，低傷害' },
            'heavy':  { type: 'single', range: 120, damage: 60, cooldown: 55, speed: 10, nameType: '重擊', desc: '攻擊高，攻速慢' },
            'line':   { type: 'line', range: 150, damage: 25, cooldown: 40, speed: 18, nameType: '穿透', desc: '直線貫穿多個敵人' },
            'splash': { type: 'splash', range: 110, damage: 40, cooldown: 60, speed: 8, nameType: '範圍', desc: '造成小範圍爆炸傷害' },
            'magic':  { type: 'magic', range: 160, damage: 20, cooldown: 50, speed: 8, nameType: '法術', desc: '範圍傷害並附加異常狀態' }
        };

        const FACTIONS = {
            'shu': {
                name: '蜀漢',
                color: '#2e7d32',
                bgColor: '#d7ccc8', 
                mapPrefixes: ['劍閣', '漢中', '祁山', '街亭', '定軍山'],
                generals: [
                    { id: 'huang', name: '黃忠', icon: '??', cost: 60, base: 'archer', color: '#4caf50' },
                    { id: 'zhao', name: '趙雲', icon: '?', cost: 90, base: 'fast', color: '#03a9f4' },
                    { id: 'guan', name: '關羽', icon: '???', cost: 120, base: 'heavy', color: '#c62828' },
                    { id: 'ma', name: '馬超', icon: '??', cost: 140, base: 'line', color: '#ff9800' },
                    { id: 'zhang', name: '張飛', icon: '??', cost: 180, base: 'splash', color: '#5d4037' },
                    { id: 'zhuge', name: '諸葛亮', icon: '??', cost: 250, base: 'magic', color: '#3f51b5', effect: 'slow' }
                ],
                decorations: ['??', '??', '??']
            },
            'wei': {
                name: '曹魏',
                color: '#1565c0',
                bgColor: '#cfd8dc', 
                mapPrefixes: ['許昌', '合肥', '樊城', '官渡', '宛城'],
                generals: [
                    { id: 'xiahou_y', name: '夏侯淵', icon: '??', cost: 60, base: 'archer', color: '#5c6bc0' },
                    { id: 'zhang_l', name: '張遼', icon: '??', cost: 90, base: 'fast', color: '#3949ab' },
                    { id: 'xiahou_d', name: '夏侯惇', icon: '???', cost: 120, base: 'heavy', color: '#283593' },
                    { id: 'xu', name: '徐晃', icon: '??', cost: 140, base: 'line', color: '#1a237e' },
                    { id: 'dian', name: '典韋', icon: '??', cost: 180, base: 'splash', color: '#0d47a1' },
                    { id: 'sima', name: '司馬懿', icon: '??', cost: 250, base: 'magic', color: '#4a148c', effect: 'stun' }
                ],
                decorations: ['??', '??', '???']
            },
            'wu': {
                name: '東吳',
                color: '#c62828',
                bgColor: '#b3e5fc', 
                mapPrefixes: ['赤壁', '夷陵', '建業', '濡須口', '柴桑'],
                generals: [
                    { id: 'sun', name: '孫尚香', icon: '??', cost: 60, base: 'archer', color: '#ef5350' },
                    { id: 'gan', name: '甘寧', icon: '??', cost: 90, base: 'fast', color: '#e53935' },
                    { id: 'taishi', name: '太史慈', icon: '???', cost: 120, base: 'heavy', color: '#c62828' },
                    { id: 'ling', name: '凌統', icon: '??', cost: 140, base: 'line', color: '#b71c1c' },
                    { id: 'huang_g', name: '黃蓋', icon: '??', cost: 180, base: 'splash', color: '#880e4f' },
                    { id: 'zhou', name: '周瑜', icon: '??', cost: 250, base: 'magic', color: '#ff5722', effect: 'burn' }
                ],
                decorations: ['??', '??', '??']
            }
        };

        const MAP_SUFFIXES = ['小徑', '戰場', '要塞', '平原', '關隘'];

        // --- Global Variables ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 40;
        const COLS = 22;
        const ROWS = 17;
        
        let gameState = {
            activeFaction: null,
            factionData: null,
            difficultyLevel: 1, 
            towers: [],
            enemies: [],
            projectiles: [],
            particles: [],
            gold: 150,
            lives: 20,
            wave: 0,
            active: false,
            spawning: false,
            enemiesToSpawn: [],
            spawnTimer: 0,
            selectedTowerType: null,
            selectedPlacedTower: null,
            gameOver: false,
            allPaths: [], // Stores valid full path arrays for enemies
            roadTiles: [], // Stores unique {x,y} for drawing
            decorations: [], 
            mapName: "",
            mouseX: 0,
            mouseY: 0
        };

        // --- Initialization ---

        function startGame(factionKey) {
            const faction = FACTIONS[factionKey];
            gameState.activeFaction = factionKey;
            gameState.factionData = faction;
            gameState.difficultyLevel = 1;
            
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('faction-label').textContent = faction.name;
            document.getElementById('faction-label').style.color = faction.color;
            
            setupTowerButtons(faction);
            generateGraphMap();
            resetGame(150);
            gameLoop();
        }

        // --- Graph-based Map Generator (Guaranteed No Dead Ends) ---
        function generateGraphMap() {
            const faction = gameState.factionData;
            
            // 1. Name
            const prefix = faction.mapPrefixes[Math.floor(Math.random() * faction.mapPrefixes.length)];
            const suffix = MAP_SUFFIXES[Math.floor(Math.random() * MAP_SUFFIXES.length)];
            gameState.mapName = `${prefix}${suffix}`;
            
            document.getElementById('faction-title').textContent = gameState.mapName;
            document.getElementById('faction-title').style.color = faction.color;
            document.getElementById('map-label').textContent = `關卡: ${gameState.difficultyLevel}`;

            // 2. Generate Graph Layers (Nodes)
            const columns = [0];
            const numMidCols = 3; 
            const segmentW = Math.floor((COLS - 2) / numMidCols);
            for(let i=1; i<=numMidCols; i++) columns.push(i * segmentW + Math.floor(Math.random()*2));
            columns.push(COLS - 1);

            const layers = []; 
            let nodeId = 0;

            // Start Node (Layer 0)
            layers.push([{ x: 0, y: Math.floor(Math.random() * (ROWS - 4)) + 2, id: nodeId++, next: [] }]);

            // Mid Nodes
            for (let i = 1; i < columns.length - 1; i++) {
                const colNodes = [];
                // In higher levels, create more branches (max 2)
                const count = (gameState.difficultyLevel >= 3 && Math.random() > 0.4) ? 2 : 1; 
                
                const ys = new Set();
                while(ys.size < count) {
                    ys.add(Math.floor(Math.random() * (ROWS - 4)) + 2);
                }
                
                ys.forEach(y => {
                    colNodes.push({ x: columns[i], y: y, id: nodeId++, next: [] });
                });
                layers.push(colNodes);
            }

            // End Node
            layers.push([{ x: COLS - 1, y: Math.floor(Math.random() * (ROWS - 4)) + 2, id: nodeId++, next: [] }]);

            // 3. Connect Layers (Edges)
            // Strategy: Connect every node in Layer i to at least one node in Layer i+1
            // AND ensure every node in Layer i+1 has at least one input from Layer i
            
            for (let i = 0; i < layers.length - 1; i++) {
                const currLayer = layers[i];
                const nextLayer = layers[i+1];

                // Randomly connect each curr to one random next
                currLayer.forEach(curr => {
                    const target = nextLayer[Math.floor(Math.random() * nextLayer.length)];
                    curr.next.push(target);
                });

                // Ensure all next nodes are reachable (avoid dead inputs)
                nextLayer.forEach(next => {
                    // Check if any curr points to this next
                    const isConnected = currLayer.some(c => c.next.includes(next));
                    if (!isConnected) {
                        // Connect a random curr to this orphaned next
                        const source = currLayer[Math.floor(Math.random() * currLayer.length)];
                        source.next.push(next);
                    }
                });
                
                // Add extra random connections for complexity if multiple nodes exist
                if (currLayer.length > 1 || nextLayer.length > 1) {
                    if (Math.random() > 0.6) {
                        const c = currLayer[Math.floor(Math.random()*currLayer.length)];
                        const n = nextLayer[Math.floor(Math.random()*nextLayer.length)];
                        if (!c.next.includes(n)) c.next.push(n);
                    }
                }
            }

            // 4. Generate Physical Paths & Trace
            gameState.allPaths = [];
            const roadTileSet = new Set();

            // DFS to find all complete paths
            function traverse(node, currentPathPoints) {
                // If we reached the end (last layer)
                if (node.next.length === 0) {
                    // Safety check if it is the end node
                    if (node.x === COLS - 1) {
                        gameState.allPaths.push(currentPathPoints.map(p => ({
                             x: p.x * GRID_SIZE + GRID_SIZE/2,
                             y: p.y * GRID_SIZE + GRID_SIZE/2
                        })));
                    }
                    return;
                }

                node.next.forEach(target => {
                    const segment = getSegmentPoints(node, target);
                    
                    // Add segment points to tile set for drawing
                    segment.forEach(p => roadTileSet.add(`${p.x},${p.y}`));
                    
                    // Recursive step: Append segment (excluding start point to avoid duplicate)
                    const newPath = [...currentPathPoints, ...segment.slice(1)];
                    traverse(target, newPath);
                });
            }

            // Start BFS/DFS
            roadTileSet.add(`${layers[0][0].x},${layers[0][0].y}`);
            traverse(layers[0][0], [layers[0][0]]);

            // 5. Store Road Tiles
            gameState.roadTiles = [];
            roadTileSet.forEach(str => {
                const [x, y] = str.split(',').map(Number);
                gameState.roadTiles.push({x: x * GRID_SIZE + GRID_SIZE/2, y: y * GRID_SIZE + GRID_SIZE/2});
            });

            // 6. Decorations
            generateDecorations(roadTileSet);
        }

        function getSegmentPoints(p1, p2) {
            const pts = [];
            let curr = {x: p1.x, y: p1.y};
            pts.push({...curr});
            
            // Randomly choose X-first or Y-first for L-shape
            // To look more natural, sometimes mix? No, L-shape is cleanest for grid TD
            if (Math.random() > 0.5) {
                // X then Y
                while(curr.x < p2.x) { curr.x++; pts.push({...curr}); }
                while(curr.y !== p2.y) { curr.y += (curr.y < p2.y ? 1 : -1); pts.push({...curr}); }
            } else {
                // Y then X
                // Only move Y if we are not at x=0 (to avoid drawing on edge weirdly) or just standard
                while(curr.y !== p2.y) { curr.y += (curr.y < p2.y ? 1 : -1); pts.push({...curr}); }
                while(curr.x < p2.x) { curr.x++; pts.push({...curr}); }
            }
            return pts;
        }

        function generateDecorations(roadTileSet) {
            const faction = gameState.factionData;
            gameState.decorations = [];
            const decoCount = 20 + Math.floor(Math.random() * 15);
            
            for (let i = 0; i < decoCount; i++) {
                const c = Math.floor(Math.random() * COLS);
                const r = Math.floor(Math.random() * ROWS);
                const key = `${c},${r}`;
                
                // Do not place on road
                if (!roadTileSet.has(key)) {
                    const icon = faction.decorations[Math.floor(Math.random() * faction.decorations.length)];
                    gameState.decorations.push({
                        x: c * GRID_SIZE + GRID_SIZE/2,
                        y: r * GRID_SIZE + GRID_SIZE/2,
                        icon: icon,
                        scale: 0.8 + Math.random() * 0.4,
                        rotation: (Math.random() - 0.5) * 0.5
                    });
                    // Add key to set to avoid stacking too much
                    roadTileSet.add(key); 
                }
            }
        }

        function setupTowerButtons(faction) {
            const grid = document.getElementById('tower-grid');
            grid.innerHTML = '';
            faction.generals.forEach((gen, index) => {
                const btn = document.createElement('div');
                btn.className = 'tower-btn';
                btn.id = `btn-${index}`;
                btn.onclick = () => selectTowerType(index);
                btn.innerHTML = `
                    <div class="tower-icon-display">${gen.icon}</div>
                    <div class="tower-name">${gen.name}</div>
                    <div class="tower-cost">??${gen.cost}</div>
                `;
                grid.appendChild(btn);
            });
        }

        function resetGame(startGold) {
            gameState.gold = startGold;
            gameState.lives = 20;
            gameState.wave = 0;
            gameState.towers = [];
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.particles = [];
            gameState.active = false;
            gameState.spawning = false;
            gameState.gameOver = false;
            deselectAll();
            updateStatsUI();
        }

        function nextLevel() {
            document.getElementById('level-screen').classList.add('hidden');
            gameState.difficultyLevel++;
            
            generateGraphMap(); // NEW MAP
            
            // Preserve Gold + Bonus
            const bonusGold = 250 + (gameState.difficultyLevel * 50);
            resetGame(gameState.gold + bonusGold);
        }

        // --- Core Logic Classes ---

        class Enemy {
            constructor(type, difficulty, path) {
                this.path = path;
                this.pathIndex = 0;
                this.x = path[0].x;
                this.y = path[0].y;
                this.type = type; 
                
                // Exponential Difficulty Scaling (1.25^Level)
                const hpMult = Math.pow(1.25, difficulty - 1); 
                const rewardMult = 1 + (difficulty * 0.1); 

                // Default Stats
                this.radius = 12;
                this.color = '#546e7a';
                this.icon = '??';
                this.baseHp = 40;
                this.speed = 1.8;
                this.baseReward = 10;
                this.scale = 1.0;
                this.name = "步兵";
                this.regen = 0;

                // --- NEW ENEMY TYPES ---
                if (type === 'scout') {
                    this.icon = '??'; this.baseHp = 25; this.speed = 2.8; this.color = '#8d6e63'; this.baseReward = 12; this.name = "斥候";
                } else if (type === 'heavy') {
                    this.icon = '???'; this.baseHp = 120; this.speed = 1.1; this.color = '#4527a0'; this.baseReward = 20; this.name = "重甲";
                } else if (type === 'cavalry') {
                    this.icon = '??'; this.baseHp = 60; this.speed = 3.2; this.color = '#ff9800'; this.baseReward = 18; this.name = "騎兵";
                } else if (type === 'taoist') {
                    this.icon = '??'; this.baseHp = 50; this.speed = 1.5; this.color = '#00acc1'; this.baseReward = 25; this.name = "道士"; this.regen = 1; // Regenerates
                } else if (type === 'general') {
                    this.icon = '??'; this.baseHp = 300; this.speed = 1.3; this.color = '#d81b60'; this.baseReward = 80; this.name = "偏將"; this.radius = 16; this.scale = 1.3;
                } else if (type === 'boss') {
                    this.icon = '??'; this.baseHp = 800; this.speed = 0.7; this.color = '#b71c1c'; this.baseReward = 300; this.radius = 22; this.scale = 1.8; this.name = "敵將";
                }

                // Elite Prefix based on difficulty
                if (difficulty > 3 && type !== 'boss' && type !== 'general') {
                    this.name = "精銳" + this.name;
                    this.baseHp *= 1.3;
                    this.color = '#c2185b';
                }
                if (difficulty > 6 && type !== 'boss') {
                    this.name = "神" + this.name;
                    this.baseHp *= 1.6;
                }

                this.maxHp = Math.floor(this.baseHp * hpMult);
                this.hp = this.maxHp;
                this.reward = Math.floor(this.baseReward * rewardMult);
                
                this.frozenTimer = 0; this.burnTimer = 0; this.stunTimer = 0;
            }

            update() {
                // Regen
                if (this.regen > 0 && this.hp < this.maxHp && this.hp > 0) {
                    if (gameState.spawnTimer % 60 === 0) { // Approx every second
                        this.hp = Math.min(this.maxHp, this.hp + (this.maxHp * 0.05));
                    }
                }

                let currentSpeed = this.speed;
                if (this.stunTimer > 0) { currentSpeed = 0; this.stunTimer--; }
                else if (this.frozenTimer > 0) { currentSpeed *= 0.5; this.frozenTimer--; }

                if (this.burnTimer > 0) {
                    if (this.burnTimer % 20 === 0) this.takeDamage(5 + Math.floor(gameState.difficultyLevel)); 
                    this.burnTimer--;
                }

                if (currentSpeed > 0) {
                    const target = this.path[this.pathIndex + 1];
                    if (target) {
                        const dx = target.x - this.x; const dy = target.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < currentSpeed) {
                            this.x = target.x; this.y = target.y; this.pathIndex++;
                            if (this.pathIndex >= this.path.length - 1) this.reachEnd();
                        } else {
                            this.x += (dx/dist)*currentSpeed; this.y += (dy/dist)*currentSpeed;
                        }
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
                
                ctx.fillStyle = '#fff'; ctx.font = `${16 * this.scale}px Arial`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.icon, this.x, this.y + 2);

                const hpPct = this.hp / this.maxHp;
                const barWidth = 24 * this.scale;
                const barY = this.y - (this.radius + 8);
                ctx.fillStyle = '#37474f'; ctx.fillRect(this.x - barWidth/2, barY, barWidth, 4);
                ctx.fillStyle = hpPct > 0.5 ? '#66bb6a' : (hpPct > 0.2 ? '#ffa726' : '#ef5350');
                ctx.fillRect(this.x - barWidth/2, barY, barWidth * hpPct, 4);
                
                // Regen effect indicator
                if (this.regen > 0) {
                    ctx.fillStyle = '#00e676';
                    ctx.font = '10px Arial';
                    ctx.fillText('+', this.x + 12, this.y - 12);
                }

                if (this.frozenTimer > 0) drawStatusIcon(this.x+8, this.y-8, '#42a5f5');
                if (this.burnTimer > 0) drawStatusIcon(this.x-8, this.y-8, '#ff5722');
                if (this.stunTimer > 0) drawStatusIcon(this.x, this.y-12, '#ffd600');
            }

            takeDamage(amt) {
                this.hp -= amt;
                if (this.hp <= 0) {
                    gameState.gold += this.reward;
                    updateStatsUI();
                    createParticles(this.x, this.y, this.color);
                    return true;
                }
                return false;
            }

            reachEnd() {
                gameState.lives--;
                this.hp = 0;
                updateStatsUI();
                if (gameState.lives <= 0) gameOver();
            }
        }

        function drawStatusIcon(x, y, color) {
            ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
        }

        class Tower {
            constructor(c, r, genIndex) {
                this.c = c; this.r = r;
                this.x = c * GRID_SIZE + GRID_SIZE/2; this.y = r * GRID_SIZE + GRID_SIZE/2;
                
                const gen = gameState.factionData.generals[genIndex];
                const base = ARCHETYPES[gen.base];
                
                this.name = gen.name; this.icon = gen.icon; this.color = gen.color; this.effect = gen.effect || null;
                this.level = 1; this.baseCost = gen.cost;
                this.damage = base.damage; this.range = base.range;
                this.cooldownMax = base.cooldown; this.type = base.type; this.projSpeed = base.speed;
                this.cooldown = 0;
            }

            update() {
                if (this.cooldown > 0) this.cooldown--;
                const target = this.findTarget();
                if (target && this.cooldown <= 0) {
                    this.shoot(target);
                    this.cooldown = this.cooldownMax;
                }
            }

            findTarget() {
                for(let e of gameState.enemies) {
                    if (Math.hypot(e.x - this.x, e.y - this.y) <= this.range) return e;
                }
                return null;
            }

            shoot(target) {
                gameState.projectiles.push({
                    x: this.x, y: this.y, target: target, damage: this.damage,
                    color: this.color, type: this.type, speed: this.projSpeed,
                    effect: this.effect, active: true,
                    angle: Math.atan2(target.y - this.y, target.x - this.x), life: 30
                });
            }

            draw() {
                ctx.fillStyle = '#3e2723'; ctx.fillRect(this.x-15, this.y-15, 30, 30);
                if (gameState.selectedPlacedTower === this) {
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath();
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI*2); ctx.stroke();
                    ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fill();
                }
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 14, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.font = '16px Arial';
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(this.icon, this.x, this.y+1);

                if (this.level > 1) {
                    ctx.fillStyle = '#ffd700';
                    for(let i=0; i<this.level; i++) ctx.fillRect(this.x - 8 + (i*5), this.y - 18, 3, 3);
                }
            }

            upgrade() {
                const cost = Math.floor(this.baseCost * 0.8);
                if (gameState.gold >= cost) {
                    gameState.gold -= cost;
                    this.level++;
                    this.damage = Math.floor(this.damage * 1.4);
                    this.range = Math.floor(this.range * 1.1);
                    this.baseCost += cost;
                    createParticles(this.x, this.y, '#ffd700');
                    updateDetailPanel();
                    updateStatsUI();
                }
            }
        }

        // --- Interaction ---

        function selectTowerType(index) {
            if (gameState.gameOver) return;
            const gen = gameState.factionData.generals[index];
            const base = ARCHETYPES[gen.base];
            if (gameState.selectedTowerType === index) { deselectAll(); } 
            else {
                gameState.selectedTowerType = index; gameState.selectedPlacedTower = null;
                const panel = document.getElementById('detail-panel');
                panel.innerHTML = `
                    <div class="detail-title"><span>${gen.icon} ${gen.name}</span><span>??${gen.cost}</span></div>
                    <div class="detail-row"><span>類型:</span><span>${base.nameType}</span></div>
                    <div class="detail-row"><span>攻擊:</span><span>${base.damage}</span></div>
                    <div class="detail-row"><span>範圍:</span><span>${base.range}</span></div>
                    <div class="detail-desc">${base.desc}</div>
                    ${gen.effect ? `<div class="detail-desc" style="color:#64b5f6">特效: ${getEffectName(gen.effect)}</div>` : ''}
                `;
                document.getElementById('action-area').classList.add('hidden');
                updateTowerButtons();
            }
        }

        function getEffectName(eff) { return eff==='slow'?"減速":eff==='stun'?"暈眩":eff==='burn'?"灼燒":""; }

        function selectPlacedTower(tower) {
            gameState.selectedPlacedTower = tower; gameState.selectedTowerType = null;
            updateDetailPanel(); updateTowerButtons();
        }

        function updateDetailPanel() {
            const t = gameState.selectedPlacedTower;
            if (!t) return;
            const upgCost = Math.floor(t.baseCost * 0.8);
            const sellCost = Math.floor(t.baseCost * 0.6);
            const panel = document.getElementById('detail-panel');
            panel.innerHTML = `
                <div class="detail-title"><span>${t.icon} ${t.name}</span><span>Lv.${t.level}</span></div>
                <div class="detail-row"><span>傷害:</span><span>${t.damage}</span></div>
                <div class="detail-row"><span>範圍:</span><span>${Math.floor(t.range)}</span></div>
                <div class="detail-desc">已佈署的武將。</div>
            `;
            document.getElementById('action-area').classList.remove('hidden');
            document.getElementById('cost-upg').textContent = `(${upgCost})`;
            document.getElementById('cost-sell').textContent = `(${sellCost})`;
            document.getElementById('btn-upgrade').disabled = gameState.gold < upgCost;
        }

        function deselectAll() {
            gameState.selectedTowerType = null; gameState.selectedPlacedTower = null;
            document.getElementById('detail-panel').innerHTML = `<div style="text-align: center; color: #757575; padding-top: 40px;">選擇武將查看詳情</div>`;
            document.getElementById('action-area').classList.add('hidden');
            updateTowerButtons();
        }

        function updateTowerButtons() {
            const btns = document.querySelectorAll('.tower-btn');
            btns.forEach((btn, idx) => {
                const gen = gameState.factionData.generals[idx];
                btn.className = 'tower-btn';
                if (gameState.selectedTowerType === idx) btn.classList.add('selected');
                if (gameState.gold < gen.cost) btn.classList.add('disabled');
            });
        }

        function actionUpgrade() { if (gameState.selectedPlacedTower) gameState.selectedPlacedTower.upgrade(); }
        function actionSell() {
            if (gameState.selectedPlacedTower) {
                const t = gameState.selectedPlacedTower;
                gameState.gold += Math.floor(t.baseCost * 0.6);
                const idx = gameState.towers.indexOf(t);
                if (idx > -1) gameState.towers.splice(idx, 1);
                createParticles(t.x, t.y, '#9e9e9e');
                deselectAll(); updateStatsUI();
            }
        }

        function updateStatsUI() {
            document.getElementById('wave-display').textContent = `${gameState.wave}/5`;
            document.getElementById('lives-display').textContent = gameState.lives;
            document.getElementById('gold-display').textContent = gameState.gold;
            updateTowerButtons();
            if (gameState.selectedPlacedTower) updateDetailPanel();
            
            const startBtn = document.getElementById('start-btn');
            if (gameState.active || gameState.spawning) {
                startBtn.disabled = true; startBtn.textContent = "戰鬥中..."; startBtn.style.backgroundColor = '#757575';
            } else {
                startBtn.disabled = false;
                startBtn.textContent = gameState.wave === 0 ? "開始戰鬥" : (gameState.wave === 4 ? "BOSS 來襲！" : "下一波");
                startBtn.style.backgroundColor = gameState.wave === 4 ? '#b71c1c' : 'var(--accent-color)';
            }
        }

        // --- Game Loop ---

        function startNextWave() {
            if (gameState.active) return;
            gameState.active = true; gameState.wave++; gameState.spawning = true;
            gameState.enemiesToSpawn = generateWaveComposition(gameState.wave);
            gameState.spawnTimer = 0; updateStatsUI();
        }

        function generateWaveComposition(wave) {
            let list = [];
            const diff = gameState.difficultyLevel;
            
            if (wave === 5) {
                // Boss Wave
                list.push('boss');
                // Adds elite minions
                for(let i=0; i<6; i++) {
                    if (diff >= 4) list.push('general'); // Late game mini-bosses
                    else list.push(Math.random()>0.5 ? 'heavy' : 'taoist');
                }
            } else {
                let count = 5 + (wave * 2) + Math.floor(diff * 1.5);
                for(let i=0; i<count; i++) {
                    let r = Math.random();
                    let type = 'soldier';
                    
                    // Unlock order based on difficulty (Level)
                    if (diff >= 2 && r < 0.25) type = 'cavalry';
                    if (diff >= 3 && r < 0.2) type = 'scout';
                    if (diff >= 4 && r < 0.15) type = 'taoist';
                    if (diff >= 5 && r < 0.15) type = 'heavy';
                    if (diff >= 7 && r < 0.05) type = 'general';

                    list.push(type);
                }
            }
            return list;
        }

        function update() {
            if (gameState.gameOver || !gameState.active) return;

            if (gameState.spawning) {
                gameState.spawnTimer++;
                let interval = 40; if(gameState.wave === 5) interval = 60;
                if (gameState.spawnTimer > interval) {
                    if (gameState.enemiesToSpawn.length > 0) {
                        // Pick random path for enemy
                        const randPath = gameState.allPaths[Math.floor(Math.random() * gameState.allPaths.length)];
                        gameState.enemies.push(new Enemy(gameState.enemiesToSpawn.shift(), gameState.difficultyLevel, randPath));
                        gameState.spawnTimer = 0;
                    } else { gameState.spawning = false; }
                }
            }

            for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                const e = gameState.enemies[i]; e.update(); if (e.hp <= 0) gameState.enemies.splice(i, 1);
            }
            gameState.towers.forEach(t => t.update());
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const p = gameState.projectiles[i];
                if (!p.active) { gameState.projectiles.splice(i, 1); continue; }
                if (p.type === 'line') {
                    p.x += Math.cos(p.angle) * p.speed; p.y += Math.sin(p.angle) * p.speed;
                    p.life--; if (p.life <= 0) p.active = false;
                    gameState.enemies.forEach(e => { if (Math.hypot(e.x - p.x, e.y - p.y) < e.radius + 5) { e.takeDamage(p.damage); createParticles(e.x, e.y, p.color); }});
                } else {
                    if (p.target.hp <= 0) { p.active = false; continue; }
                    const dx = p.target.x - p.x; const dy = p.target.y - p.y; const dist = Math.hypot(dx, dy);
                    if (dist < p.speed) {
                        p.active = false;
                        const targets = [];
                        if (p.type === 'splash' || p.type === 'magic') {
                            gameState.enemies.forEach(e => { if (Math.hypot(e.x - p.target.x, e.y - p.target.y) < (p.type==='splash'?60:50)) targets.push(e); });
                        } else { targets.push(p.target); }
                        
                        targets.forEach(e => {
                            e.takeDamage(p.damage);
                            if (p.effect === 'slow') e.frozenTimer = 90;
                            if (p.effect === 'stun') e.stunTimer = 30;
                            if (p.effect === 'burn') e.burnTimer = 120;
                        });
                        createParticles(p.target.x, p.target.y, p.color);
                    } else { p.x += (dx/dist)*p.speed; p.y += (dy/dist)*p.speed; }
                }
            }
            for (let i = gameState.particles.length - 1; i >= 0; i--) {
                gameState.particles[i].update(); if (gameState.particles[i].life <= 0) gameState.particles.splice(i, 1);
            }

            if (!gameState.spawning && gameState.enemies.length === 0) {
                gameState.active = false;
                if (gameState.wave === 5) {
                    const bonus = 250 + (gameState.difficultyLevel * 50);
                    document.getElementById('level-reward').textContent = `獎勵: ${bonus} 庫銀 (庫銀將保留至下一關)`;
                    document.getElementById('level-screen').classList.remove('hidden');
                } else {
                    gameState.gold += 50 + (gameState.difficultyLevel * 10);
                    updateStatsUI();
                }
            }
        }

        function draw() {
            ctx.fillStyle = gameState.factionData ? gameState.factionData.bgColor : '#1a100e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!gameState.factionData) return;

            // Draw Decorations
            gameState.decorations.forEach(d => {
                ctx.save();
                ctx.translate(d.x, d.y);
                ctx.scale(d.scale, d.scale);
                ctx.rotate(d.rotation);
                ctx.font = '24px serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(d.icon, 0, 0);
                ctx.restore();
            });

            // Draw Road Network
            ctx.lineWidth = 30; 
            ctx.lineCap = 'round'; 
            ctx.lineJoin = 'round';
            ctx.strokeStyle = 'rgba(0,0,0,0.15)'; 
            
            // Draw all path segments stored in roadTiles? 
            // Better: just draw all paths from allPaths. Since they are consistent, it visually merges.
            gameState.allPaths.forEach(path => {
                ctx.beginPath();
                if (path.length > 0) {
                    ctx.moveTo(path[0].x, path[0].y);
                    for(let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.stroke();
            });

            gameState.towers.forEach(t => t.draw());
            gameState.enemies.forEach(e => e.draw());
            gameState.projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); });
            gameState.particles.forEach(p => p.draw());

            if (gameState.selectedTowerType !== null && gameState.factionData) {
                const c = Math.floor(gameState.mouseX / GRID_SIZE);
                const r = Math.floor(gameState.mouseY / GRID_SIZE);
                if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                    const x = c * GRID_SIZE + GRID_SIZE/2; const y = r * GRID_SIZE + GRID_SIZE/2;
                    const gen = gameState.factionData.generals[gameState.selectedTowerType];
                    const base = ARCHETYPES[gen.base];
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = isPath(c,r) ? '#ef5350' : gen.color;
                    ctx.beginPath(); ctx.arc(x, y, 15, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(x, y, base.range, 0, Math.PI*2); ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
            }
        }

        canvas.addEventListener('click', (e) => {
            if (gameState.gameOver || !gameState.factionData) return;
            const rect = canvas.getBoundingClientRect();
            const c = Math.floor((e.clientX - rect.left) / GRID_SIZE);
            const r = Math.floor((e.clientY - rect.top) / GRID_SIZE);
            if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return;

            const clicked = gameState.towers.find(t => t.c === c && t.r === r);
            if (clicked) { selectPlacedTower(clicked); return; }

            if (gameState.selectedTowerType !== null) {
                if (isPath(c, r)) return;
                const gen = gameState.factionData.generals[gameState.selectedTowerType];
                if (gameState.gold >= gen.cost) {
                    gameState.gold -= gen.cost;
                    gameState.towers.push(new Tower(c, r, gameState.selectedTowerType));
                    createParticles(c*GRID_SIZE+20, r*GRID_SIZE+20, '#fff');
                    updateStatsUI();
                }
            } else { deselectAll(); }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.mouseX = e.clientX - rect.left;
            gameState.mouseY = e.clientY - rect.top;
        });

        function isPath(c, r) {
            // Check against roadTiles set for precision
            return gameState.roadTiles.some(t => {
                const tc = Math.floor(t.x / GRID_SIZE);
                const tr = Math.floor(t.y / GRID_SIZE);
                return tc === c && tr === r;
            });
        }

        function createParticles(x, y, color) { for(let i=0; i<6; i++) gameState.particles.push(new Particle(x, y, color)); }
        class Particle {
            constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.life = 20; this.vx = (Math.random()-0.5)*4; this.vy = (Math.random()-0.5)*4; }
            update() { this.x+=this.vx; this.y+=this.vy; this.life--; }
            draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 3, 3); }
        }

        function gameOver() {
            gameState.gameOver = true; gameState.active = false;
            document.getElementById('end-screen').classList.remove('hidden');
            document.getElementById('end-desc').textContent = `你的霸業在第 ${gameState.difficultyLevel} 關，第 ${gameState.wave} 波結束了。`;
        }

        function gameLoop() { update(); draw(); if (!gameState.gameOver) requestAnimationFrame(gameLoop); }

        draw(); 
    </script>
</body>
</html>