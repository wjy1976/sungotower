<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三國演義：無限戰役 (完美路徑修復版)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap');

        :root {
            --bg-color: #f4e4bc;
            --panel-color: #3e2723;
            --text-color: #f4e4bc;
            --accent-color: #d32f2f;
            --shu-color: #2e7d32;
            --wei-color: #1565c0;
            --wu-color: #c62828;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #1a100e;
            font-family: 'Noto Serif TC', serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            color: #333;
            user-select: none;
        }

        #game-wrapper {
            position: relative;
            width: 1200px;
            height: 700px;
            background-color: var(--bg-color);
            border: 4px solid var(--panel-color);
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            display: flex;
            flex-direction: row;
        }

        /* --- Screens --- */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 100;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            transition: opacity 0.3s;
        }

        .hidden {
            display: none !important;
            opacity: 0;
            pointer-events: none;
        }

        /* Menu Styles */
        .faction-select { display: flex; gap: 20px; margin-top: 40px; }
        .faction-card {
            width: 200px; height: 320px; border: 4px solid #555; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s; background: rgba(255,255,255,0.1);
        }
        .faction-card:hover { transform: translateY(-10px); box-shadow: 0 0 20px rgba(255,215,0,0.3); }
        .faction-shu { border-color: var(--shu-color); }
        .faction-shu:hover { background: linear-gradient(to bottom, rgba(46,125,50,0.2), transparent); }
        .faction-wei { border-color: var(--wei-color); }
        .faction-wei:hover { background: linear-gradient(to bottom, rgba(21,101,192,0.2), transparent); }
        .faction-wu { border-color: var(--wu-color); }
        .faction-wu:hover { background: linear-gradient(to bottom, rgba(198,40,40,0.2), transparent); }
        .faction-symbol { font-size: 80px; margin-bottom: 20px; }
        .faction-name { font-size: 32px; font-weight: bold; margin-bottom: 10px; }
        .faction-desc { font-size: 14px; text-align: center; padding: 0 15px; color: #ccc; line-height: 1.5; }

        /* Level Complete Screen */
        #level-screen h2 { font-size: 40px; color: #ffd700; margin-bottom: 10px; }
        #level-screen p { font-size: 18px; color: #eee; margin-bottom: 30px; }
        .next-btn {
            background: linear-gradient(#4caf50, #2e7d32); border: 2px solid #a5d6a7;
            padding: 15px 40px; font-size: 24px; color: white; cursor: pointer;
            border-radius: 8px; font-family: 'Noto Serif TC', serif; font-weight: bold;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .next-btn:hover { transform: scale(1.05); }

        /* Game UI */
        #game-canvas { flex-grow: 1; background-color: #dccbba; cursor: crosshair; }
        #ui-sidebar {
            width: 320px; background-color: var(--panel-color); color: var(--text-color);
            padding: 15px; display: flex; flex-direction: column; border-left: 4px solid #1a100e;
            box-sizing: border-box; z-index: 10;
        }
        h1 { margin: 0 0 10px 0; font-size: 22px; text-align: center; border-bottom: 2px solid var(--text-color); padding-bottom: 10px; color: #ffb74d; }
        .header-info { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 14px; color: #bdbdbd; }
        .stats-panel {
            display: flex; justify-content: space-between; margin-bottom: 15px;
            background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px;
        }
        .stat-item { display: flex; flex-direction: column; align-items: center; font-size: 13px; }
        .stat-value { font-size: 18px; font-weight: bold; color: #ffb74d; margin-top: 4px; }
        .tower-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        .tower-btn {
            display: flex; flex-direction: column; align-items: center; background-color: #4e342e;
            border: 2px solid #6d4c41; padding: 6px; cursor: pointer; border-radius: 4px; transition: all 0.1s;
        }
        .tower-btn:hover { background-color: #5d4037; border-color: #ffb74d; }
        .tower-btn.selected { background-color: #1b5e20; border-color: #66bb6a; box-shadow: 0 0 8px #66bb6a; }
        .tower-btn.disabled { opacity: 0.5; filter: grayscale(1); cursor: not-allowed; }
        .tower-icon-display { font-size: 20px; margin-bottom: 2px; }
        .tower-name { font-size: 14px; font-weight: bold; }
        .tower-cost { font-size: 12px; color: #ffcc80; }
        #detail-panel {
            background: rgba(0,0,0,0.3); border: 1px solid #8d6e63; padding: 10px;
            border-radius: 4px; margin-bottom: 10px; font-size: 13px; min-height: 120px;
        }
        .detail-title { color: #ffb74d; font-weight: bold; font-size: 15px; margin-bottom: 5px; border-bottom: 1px solid #5d4037; padding-bottom: 3px; display: flex; justify-content: space-between; }
        .detail-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .detail-desc { margin-top: 8px; color: #e0e0e0; font-style: italic; line-height: 1.4; }
        .action-row { display: flex; gap: 5px; margin-top: auto; margin-bottom: 10px; }
        .btn-mini { flex: 1; padding: 8px; border: none; border-radius: 4px; cursor: pointer; color: white; font-weight: bold; font-family: inherit; }
        .btn-upg { background-color: #2e7d32; }
        .btn-upg:disabled { background-color: #1b5e20; opacity: 0.5; }
        .btn-sell { background-color: #c62828; }
        #start-btn {
            width: 100%; padding: 12px; font-family: inherit; font-size: 18px; font-weight: bold;
            background-color: var(--accent-color); color: white; border: none; cursor: pointer;
            border-radius: 4px; box-shadow: 0 4px #b71c1c; margin-top: auto;
        }
        #start-btn:active { transform: translateY(4px); box-shadow: none; }
        #start-btn:disabled { background-color: #757575; box-shadow: none; }
        .back-btn {
            position: absolute; top: 10px; left: 10px; background: transparent;
            border: 1px solid #ffb74d; color: #ffb74d; padding: 5px 15px; cursor: pointer; font-family: inherit; z-index: 200;
        }
        .back-btn:hover { background: rgba(255, 183, 77, 0.2); }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="menu-screen" class="screen">
            <h1 style="font-size: 48px; border: none; margin-bottom: 10px;">三國：群雄割據</h1>
            <p style="color: #bbb; margin-bottom: 40px; font-size: 18px;">選擇陣營 · 無限戰場 · 策略攻防</p>
            <div class="faction-select">
                <div class="faction-card faction-shu" onclick="startGame('shu')">
                    <div class="faction-symbol" style="color: var(--shu-color)">蜀</div>
                    <div class="faction-name">蜀漢</div>
                    <div class="faction-desc">山道險要<br>武將：五虎上將<br>特性：防守/控制</div>
                </div>
                <div class="faction-card faction-wei" onclick="startGame('wei')">
                    <div class="faction-symbol" style="color: var(--wei-color)">魏</div>
                    <div class="faction-name">曹魏</div>
                    <div class="faction-desc">城池堅固<br>五子良將<br>特性：爆發/範圍</div>
                </div>
                <div class="faction-card faction-wu" onclick="startGame('wu')">
                    <div class="faction-symbol" style="color: var(--wu-color)">吳</div>
                    <div class="faction-name">東吳</div>
                    <div class="faction-desc">水寨連環<br>江東虎臣<br>特性：灼燒/攻速</div>
                </div>
            </div>
        </div>

        <div id="level-screen" class="screen hidden">
            <h2 id="level-title">大獲全勝</h2>
            <p id="level-desc">敵軍潰敗，我軍乘勝追擊！</p>
            <p id="level-reward" style="font-size: 16px; color: #66bb6a; margin-top: -10px; margin-bottom: 20px;"></p>
            <button class="next-btn" onclick="nextLevel()">進軍下一關 (保留資金)</button>
        </div>

        <div id="end-screen" class="screen hidden">
            <h2 id="end-title" style="font-size: 40px; color: #ef5350;">城池失守</h2>
            <p id="end-desc" style="font-size: 18px; margin: 20px 0;">...</p>
            <button onclick="location.reload()" style="padding: 10px 30px; font-size: 18px; cursor: pointer;">返回標題</button>
        </div>

        <canvas id="game-canvas" width="880" height="700"></canvas>
        
        <aside id="ui-sidebar">
            <div class="header-info">
                <span id="faction-label">陣營</span>
                <span id="map-label">關卡: 1</span>
            </div>
            <h1 id="faction-title">地圖名</h1>
            <div class="stats-panel">
                <div class="stat-item"><span>波次</span><span id="wave-display" class="stat-value">1/5</span></div>
                <div class="stat-item"><span>耐久</span><span id="lives-display" class="stat-value" style="color: #ef5350;">20</span></div>
                <div class="stat-item"><span>庫銀</span><span id="gold-display" class="stat-value" style="color: #ffd700;">150</span></div>
            </div>
            <div id="tower-grid" class="tower-grid"></div>
            <div id="detail-panel"><div style="text-align: center; color: #757575; padding-top: 40px;">選擇武將查看詳情</div></div>
            <div id="action-area" class="action-row hidden">
                <button id="btn-upgrade" class="btn-mini btn-upg" onclick="actionUpgrade()">晉升 <span id="cost-upg">(100)</span></button>
                <button id="btn-sell" class="btn-mini btn-sell" onclick="actionSell()">撤退 <span id="cost-sell">(50)</span></button>
            </div>
            <button id="start-btn" onclick="startNextWave()">進攻開始</button>
        </aside>
        <button class="back-btn" onclick="location.reload()">退出戰役</button>
    </div>

    <script>
        const ARCHETYPES = {
            'archer': { type: 'single', range: 180, damage: 15, cooldown: 25, speed: 12, nameType: '神射', desc: '射程遠，攻速中等' },
            'fast':   { type: 'single', range: 130, damage: 8, cooldown: 10, speed: 15, nameType: '突擊', desc: '攻速極快，低傷害' },
            'heavy':  { type: 'single', range: 120, damage: 60, cooldown: 55, speed: 10, nameType: '重擊', desc: '攻擊高，攻速慢' },
            'line':   { type: 'line', range: 150, damage: 25, cooldown: 40, speed: 18, nameType: '穿透', desc: '直線貫穿多個敵人' },
            'splash': { type: 'splash', range: 110, damage: 40, cooldown: 60, speed: 8, nameType: '範圍', desc: '造成小範圍爆炸傷害' },
            'magic':  { type: 'magic', range: 160, damage: 20, cooldown: 50, speed: 8, nameType: '法術', desc: '範圍傷害並附加異常狀態' }
        };

        const FACTIONS = {
            'shu': {
                name: '蜀漢', color: '#2e7d32', bgColor: '#d7ccc8', mapPrefixes: ['劍閣', '漢中', '祁山', '街亭', '定軍山'],
                generals: [
                    { id: 'huang', name: '黃忠', icon: '\u{1F3F9}', cost: 60, base: 'archer', color: '#4caf50' },
                    { id: 'zhao', name: '趙雲', icon: '\u{26A1}', cost: 90, base: 'fast', color: '#03a9f4' },
                    { id: 'guan', name: '關羽', icon: '\u{1F5E1}', cost: 120, base: 'heavy', color: '#c62828' },
                    { id: 'ma', name: '馬超', icon: '\u{1F40E}', cost: 140, base: 'line', color: '#ff9800' },
                    { id: 'zhang', name: '張飛', icon: '\u{1F4A5}', cost: 180, base: 'splash', color: '#5d4037' },
                    { id: 'zhuge', name: '諸葛亮', icon: '\u{262F}', cost: 250, base: 'magic', color: '#3f51b5', effect: 'slow' }
                ],
                decorations: ['\u{1F332}', '\u{1FAA8}', '\u{26F0}']
            },
            'wei': {
                name: '曹魏', color: '#1565c0', bgColor: '#cfd8dc', mapPrefixes: ['許昌', '合肥', '樊城', '官渡', '宛城'],
                generals: [
                    { id: 'xiahou_y', name: '夏侯淵', icon: '\u{1F3F9}', cost: 60, base: 'archer', color: '#5c6bc0' },
                    { id: 'zhang_l', name: '張遼', icon: '\u{2694}', cost: 90, base: 'fast', color: '#3949ab' },
                    { id: 'xiahou_d', name: '夏侯惇', icon: '\u{1F441}', cost: 120, base: 'heavy', color: '#283593' },
                    { id: 'xu', name: '徐晃', icon: '\u{1FA93}', cost: 140, base: 'line', color: '#1a237e' },
                    { id: 'dian', name: '典韋', icon: '\u{1F4AA}', cost: 180, base: 'splash', color: '#0d47a1' },
                    { id: 'sima', name: '司馬懿', icon: '\u{1F52E}', cost: 250, base: 'magic', color: '#4a148c', effect: 'stun' }
                ],
                decorations: ['\u{1F9F1}', '\u{1F33E}', '\u{1F3DA}']
            },
            'wu': {
                name: '東吳', color: '#c62828', bgColor: '#b3e5fc', mapPrefixes: ['赤壁', '夷陵', '建業', '濡須口', '柴桑'],
                generals: [
                    { id: 'sun', name: '孫尚香', icon: '\u{1F3F9}', cost: 60, base: 'archer', color: '#ef5350' },
                    { id: 'gan', name: '甘寧', icon: '\u{1F514}', cost: 90, base: 'fast', color: '#e53935' },
                    { id: 'taishi', name: '太史慈', icon: '\u{1F6E1}', cost: 120, base: 'heavy', color: '#c62828' },
                    { id: 'ling', name: '凌統', icon: '\u{1F531}', cost: 140, base: 'line', color: '#b71c1c' },
                    { id: 'huang_g', name: '黃蓋', icon: '\u{1F4A3}', cost: 180, base: 'splash', color: '#880e4f' },
                    { id: 'zhou', name: '周瑜', icon: '\u{1F525}', cost: 250, base: 'magic', color: '#ff5722', effect: 'burn' }
                ],
                decorations: ['\u{1F343}', '\u{3030}', '\u{1F41F}']
            }
        };

        const MAP_SUFFIXES = ['小徑', '戰場', '要塞', '平原', '關隘'];
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 40;
        const COLS = 22;
        const ROWS = 17;
        
        let gameState = {
            activeFaction: null, factionData: null, difficultyLevel: 1, 
            towers: [], enemies: [], projectiles: [], particles: [],
            gold: 150, lives: 20, wave: 0, active: false, spawning: false,
            enemiesToSpawn: [], spawnTimer: 0,
            selectedTowerType: null, selectedPlacedTower: null, gameOver: false,
            allPaths: [], roadTiles: [], decorations: [], mapName: "",
            mouseX: 0, mouseY: 0
        };

        function startGame(factionKey) {
            const faction = FACTIONS[factionKey];
            gameState.activeFaction = factionKey;
            gameState.factionData = faction;
            gameState.difficultyLevel = 1;
            document.getElementById('menu-screen').classList.add('hidden');
            document.getElementById('faction-label').textContent = faction.name;
            document.getElementById('faction-label').style.color = faction.color;
            setupTowerButtons(faction);
            generateForkMap();
            resetGame(150);
            gameLoop();
        }

        // --- FIXED Map Generator ---
        // Uses purely Grid Coordinates for calculation, converts to Pixel only at storage
        function generateForkMap() {
            const faction = gameState.factionData;
            const prefix = faction.mapPrefixes[Math.floor(Math.random() * faction.mapPrefixes.length)];
            const suffix = MAP_SUFFIXES[Math.floor(Math.random() * MAP_SUFFIXES.length)];
            gameState.mapName = `${prefix}${suffix}`;
            
            document.getElementById('faction-title').textContent = gameState.mapName;
            document.getElementById('faction-title').style.color = faction.color;
            document.getElementById('map-label').textContent = `關卡: ${gameState.difficultyLevel}`;

            // 1. Generate Main Path (Grid Coords)
            // Start at (0, random Y), End at (21, random Y)
            const startY = 3 + Math.floor(Math.random() * (ROWS - 6));
            const endY = 3 + Math.floor(Math.random() * (ROWS - 6));
            
            // Allow main path to deviate in Y
            let mainPathGrid = createPathGrid({x: 0, y: startY}, {x: COLS-1, y: endY}, true); 
            
            // 2. Generate Loops
            let pathsGrid = [mainPathGrid];
            let numLoops = 1;
            if (gameState.difficultyLevel >= 3) numLoops = 2;
            if (gameState.difficultyLevel >= 6) numLoops = 3;

            for (let i = 0; i < numLoops; i++) {
                if (mainPathGrid.length < 10) break;
                
                let startIdx = Math.floor(Math.random() * (mainPathGrid.length - 8)) + 2;
                let endIdx = startIdx + 5 + Math.floor(Math.random() * 5);
                if (endIdx >= mainPathGrid.length - 2) endIdx = mainPathGrid.length - 2;

                if (startIdx < endIdx) {
                    let startNode = mainPathGrid[startIdx];
                    let endNode = mainPathGrid[endIdx];
                    
                    // Force deviation for loop
                    let altPathGrid = createPathGrid(startNode, endNode, true, true);
                    
                    // Stitch full path
                    let fullPath = [];
                    for(let k=0; k<=startIdx; k++) fullPath.push(mainPathGrid[k]);
                    for(let k=1; k<altPathGrid.length-1; k++) fullPath.push(altPathGrid[k]);
                    for(let k=endIdx; k<mainPathGrid.length; k++) fullPath.push(mainPathGrid[k]);
                    pathsGrid.push(fullPath);
                }
            }

            // 3. Convert to Pixels for Game Engine
            gameState.allPaths = pathsGrid.map(path => path.map(p => toPixel(p)));

            // 4. Tiles for drawing
            const roadTileSet = new Set();
            pathsGrid.forEach(path => {
                path.forEach(p => roadTileSet.add(`${p.x},${p.y}`));
            });
            gameState.roadTiles = [];
            roadTileSet.forEach(str => {
                const [x, y] = str.split(',').map(Number);
                gameState.roadTiles.push(toPixel({x, y}));
            });

            generateDecorations(roadTileSet);
        }

        // Generate path between two GRID points
        function createPathGrid(start, end, varyY = false, forceDeviation = false) {
            let path = [];
            let curr = {x: start.x, y: start.y};
            path.push({...curr});
            
            let midX = Math.floor((start.x + end.x) / 2);
            let midY;
            
            if (forceDeviation) {
                // Pick a Y far from center line
                let dir = Math.random() > 0.5 ? 1 : -1;
                midY = curr.y + (dir * (4 + Math.floor(Math.random() * 3)));
                // Clamp
                midY = Math.max(2, Math.min(ROWS-3, midY));
            } else if (varyY) {
                midY = Math.floor((start.y + end.y) / 2) + (Math.random() > 0.5 ? 2 : -2);
                midY = Math.max(2, Math.min(ROWS-3, midY));
            } else {
                midY = curr.y;
            }

            // Move X to mid, then Y to mid, then X to end, then Y to end
            // To ensure connectivity we move 1 step at a time
            while (curr.x !== midX) { curr.x += (curr.x < midX ? 1 : -1); path.push({...curr}); }
            while (curr.y !== midY) { curr.y += (curr.y < midY ? 1 : -1); path.push({...curr}); }
            while (curr.x !== end.x) { curr.x += (curr.x < end.x ? 1 : -1); path.push({...curr}); }
            while (curr.y !== end.y) { curr.y += (curr.y < end.y ? 1 : -1); path.push({...curr}); }

            return path;
        }

        function toPixel(gridPt) {
            return { x: gridPt.x * GRID_SIZE + GRID_SIZE/2, y: gridPt.y * GRID_SIZE + GRID_SIZE/2 };
        }

        function generateDecorations(roadTileSet) {
            const faction = gameState.factionData;
            gameState.decorations = [];
            const decoCount = 20 + Math.floor(Math.random() * 10);
            for (let i = 0; i < decoCount; i++) {
                const c = Math.floor(Math.random() * COLS);
                const r = Math.floor(Math.random() * ROWS);
                if (!roadTileSet.has(`${c},${r}`)) {
                    const icon = faction.decorations[Math.floor(Math.random() * faction.decorations.length)];
                    gameState.decorations.push({
                        x: c * GRID_SIZE + GRID_SIZE/2, y: r * GRID_SIZE + GRID_SIZE/2,
                        icon: icon, scale: 0.8 + Math.random() * 0.4, rotation: (Math.random() - 0.5) * 0.5
                    });
                }
            }
        }

        function setupTowerButtons(faction) {
            const grid = document.getElementById('tower-grid');
            grid.innerHTML = '';
            faction.generals.forEach((gen, index) => {
                const btn = document.createElement('div');
                btn.className = 'tower-btn'; btn.id = `btn-${index}`;
                btn.onclick = () => selectTowerType(index);
                btn.innerHTML = `<div class="tower-icon-display">${gen.icon}</div><div class="tower-name">${gen.name}</div><div class="tower-cost">💰${gen.cost}</div>`;
                grid.appendChild(btn);
            });
        }

        function resetGame(startGold) {
            gameState.gold = startGold; gameState.lives = 20; gameState.wave = 0;
            gameState.towers = []; gameState.enemies = []; gameState.projectiles = []; gameState.particles = [];
            gameState.active = false; gameState.spawning = false; gameState.gameOver = false;
            deselectAll(); updateStatsUI();
        }

        function nextLevel() {
            document.getElementById('level-screen').classList.add('hidden');
            gameState.difficultyLevel++;
            generateForkMap();
            const bonusGold = 250 + (gameState.difficultyLevel * 50);
            resetGame(gameState.gold + bonusGold);
        }

        class Enemy {
            constructor(type, difficulty, path) {
                this.path = path; this.pathIndex = 0;
                this.x = path[0].x; this.y = path[0].y;
                this.type = type; 
                
                // HP 成長公式: 1.25 的 (難度-1) 次方
                const hpMult = Math.pow(1.25, difficulty - 1);
                
                // 獎金成長公式 (新): 1.12 的 (難度-1) 次方
                // 讓後期獎金也能跟上防禦塔升級的通膨需求
                const rewardMult = Math.pow(1.12, difficulty - 1); 

                this.radius = 12; this.color = '#546e7a'; this.icon = '\u{1F482}';
                this.baseHp = 40; this.speed = 1.8; this.baseReward = 8; // 基礎步兵
                this.scale = 1.0; this.name = "步兵"; this.regen = 0;

                // 設定各兵種的基礎能力與獎金 (能力越強，基礎獎金越高)
                if (type === 'scout') { 
                    this.icon = '\u{1F406}'; this.baseHp = 25; this.speed = 2.8; this.color = '#8d6e63'; 
                    this.baseReward = 10; this.name = "斥候"; 
                }
                else if (type === 'heavy') { 
                    this.icon = '\u{1F6E1}'; this.baseHp = 120; this.speed = 1.1; this.color = '#4527a0'; 
                    this.baseReward = 18; this.name = "重甲"; // 高血量，獎金較高
                }
                else if (type === 'cavalry') { 
                    this.icon = '\u{1F40E}'; this.baseHp = 60; this.speed = 3.2; this.color = '#ff9800'; 
                    this.baseReward = 15; this.name = "騎兵"; 
                }
                else if (type === 'taoist') { 
                    this.icon = '\u{262F}'; this.baseHp = 50; this.speed = 1.5; this.color = '#00acc1'; 
                    this.baseReward = 20; this.name = "道士"; this.regen = 1; // 會回血，獎金較高
                }
                else if (type === 'general') { 
                    this.icon = '\u{1F47A}'; this.baseHp = 300; this.speed = 1.3; this.color = '#d81b60'; 
                    this.baseReward = 80; this.name = "偏將"; this.radius = 16; this.scale = 1.3; // 小BOSS
                }
                else if (type === 'boss') { 
                    this.icon = '\u{1F479}'; this.baseHp = 800; this.speed = 0.7; this.color = '#b71c1c'; 
                    this.baseReward = 350; this.radius = 22; this.scale = 1.8; this.name = "敵將"; // BOSS獎金豐厚
                }

                // 精銳與神級單位的加成 (隨難度出現)
                if (difficulty > 3 && type !== 'boss' && type !== 'general') { 
                    this.name = "精銳" + this.name; 
                    this.baseHp *= 1.4; 
                    this.baseReward *= 1.5; // 精銳單位獎金 +50%
                    this.color = '#c2185b'; 
                }
                if (difficulty > 6 && type !== 'boss') { 
                    this.name = "神" + this.name; 
                    this.baseHp *= 1.8; 
                    this.baseReward *= 2.5; // 神級單位獎金 +150%
                }

                this.maxHp = Math.floor(this.baseHp * hpMult);
                this.hp = this.maxHp;
                this.reward = Math.floor(this.baseReward * rewardMult);
                
                this.frozenTimer = 0; this.burnTimer = 0; this.stunTimer = 0;
            }

            update() {
                if (this.regen > 0 && this.hp < this.maxHp && this.hp > 0 && gameState.spawnTimer % 60 === 0) {
                    this.hp = Math.min(this.maxHp, this.hp + (this.maxHp * 0.05));
                }
                let currentSpeed = this.speed;
                if (this.stunTimer > 0) { currentSpeed = 0; this.stunTimer--; }
                else if (this.frozenTimer > 0) { currentSpeed *= 0.5; this.frozenTimer--; }
                if (this.burnTimer > 0) {
                    if (this.burnTimer % 20 === 0) this.takeDamage(5 + Math.floor(gameState.difficultyLevel));
                    this.burnTimer--;
                }
                if (currentSpeed > 0) {
                    const target = this.path[this.pathIndex + 1];
                    if (target) {
                        const dx = target.x - this.x; const dy = target.y - this.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist < currentSpeed) {
                            this.x = target.x; this.y = target.y; this.pathIndex++;
                            if (this.pathIndex >= this.path.length - 1) this.reachEnd();
                        } else {
                            this.x += (dx/dist)*currentSpeed; this.y += (dy/dist)*currentSpeed;
                        }
                    }
                }
            }

            draw() {
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
                ctx.fillStyle = '#fff'; ctx.font = `${16 * this.scale}px Arial`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.icon, this.x, this.y + 2);
                
                const hpPct = this.hp / this.maxHp;
                const barWidth = 24 * this.scale; const barY = this.y - (this.radius + 8);
                ctx.fillStyle = '#37474f'; ctx.fillRect(this.x - barWidth/2, barY, barWidth, 4);
                ctx.fillStyle = hpPct > 0.5 ? '#66bb6a' : (hpPct > 0.2 ? '#ffa726' : '#ef5350');
                ctx.fillRect(this.x - barWidth/2, barY, barWidth * hpPct, 4);
                
                if (this.regen > 0) { ctx.fillStyle = '#00e676'; ctx.font = '10px Arial'; ctx.fillText('+', this.x + 12, this.y - 12); }
                if (this.frozenTimer > 0) drawStatusIcon(this.x+8, this.y-8, '#42a5f5');
                if (this.burnTimer > 0) drawStatusIcon(this.x-8, this.y-8, '#ff5722');
                if (this.stunTimer > 0) drawStatusIcon(this.x, this.y-12, '#ffd600');
            }

            takeDamage(amt) {
                this.hp -= amt;
                if (this.hp <= 0) {
                    gameState.gold += this.reward; updateStatsUI();
                    createParticles(this.x, this.y, this.color); return true;
                }
                return false;
            }

            reachEnd() { gameState.lives--; this.hp = 0; updateStatsUI(); if (gameState.lives <= 0) gameOver(); }
        }

        function drawStatusIcon(x, y, color) { ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill(); }

        class Tower {
            constructor(c, r, genIndex) {
                this.c = c; this.r = r; this.x = c * GRID_SIZE + GRID_SIZE/2; this.y = r * GRID_SIZE + GRID_SIZE/2;
                const gen = gameState.factionData.generals[genIndex]; const base = ARCHETYPES[gen.base];
                this.name = gen.name; this.icon = gen.icon; this.color = gen.color; this.effect = gen.effect || null;
                this.level = 1; this.baseCost = gen.cost; this.damage = base.damage; this.range = base.range;
                this.cooldownMax = base.cooldown; this.type = base.type; this.projSpeed = base.speed; this.cooldown = 0;
            }
            update() {
                if (this.cooldown > 0) this.cooldown--;
                const target = this.findTarget();
                if (target && this.cooldown <= 0) { this.shoot(target); this.cooldown = this.cooldownMax; }
            }
            findTarget() { for(let e of gameState.enemies) { if (Math.hypot(e.x - this.x, e.y - this.y) <= this.range) return e; } return null; }
            shoot(target) {
                gameState.projectiles.push({
                    x: this.x, y: this.y, target: target, damage: this.damage, color: this.color, type: this.type, speed: this.projSpeed,
                    effect: this.effect, active: true, angle: Math.atan2(target.y - this.y, target.x - this.x), life: 30
                });
            }
            draw() {
                ctx.fillStyle = '#3e2723'; ctx.fillRect(this.x-15, this.y-15, 30, 30);
                if (gameState.selectedPlacedTower === this) {
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(this.x, this.y, this.range, 0, Math.PI*2); ctx.stroke(); ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fill();
                }
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 14, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(this.icon, this.x, this.y+1);
                if (this.level > 1) { ctx.fillStyle = '#ffd700'; for(let i=0; i<this.level; i++) ctx.fillRect(this.x - 8 + (i*5), this.y - 18, 3, 3); }
            }
            upgrade() {
                const cost = Math.floor(this.baseCost * 0.8);
                if (gameState.gold >= cost) {
                    gameState.gold -= cost; this.level++; this.damage = Math.floor(this.damage * 1.4);
                    this.range = Math.floor(this.range * 1.1); this.baseCost += cost;
                    createParticles(this.x, this.y, '#ffd700'); updateDetailPanel(); updateStatsUI();
                }
            }
        }

        function selectTowerType(index) {
            if (gameState.gameOver) return;
            const gen = gameState.factionData.generals[index]; const base = ARCHETYPES[gen.base];
            if (gameState.selectedTowerType === index) deselectAll();
            else {
                gameState.selectedTowerType = index; gameState.selectedPlacedTower = null;
                const panel = document.getElementById('detail-panel');
                panel.innerHTML = `<div class="detail-title"><span>${gen.icon} ${gen.name}</span><span>💰${gen.cost}</span></div><div class="detail-row"><span>類型:</span><span>${base.nameType}</span></div><div class="detail-row"><span>攻擊:</span><span>${base.damage}</span></div><div class="detail-row"><span>範圍:</span><span>${base.range}</span></div><div class="detail-desc">${base.desc}</div>${gen.effect ? `<div class="detail-desc" style="color:#64b5f6">特效: ${gen.effect==='slow'?"減速":gen.effect==='stun'?"暈眩":gen.effect==='burn'?"灼燒":""}</div>` : ''}`;
                document.getElementById('action-area').classList.add('hidden'); updateTowerButtons();
            }
        }

        function selectPlacedTower(tower) {
            gameState.selectedPlacedTower = tower; gameState.selectedTowerType = null; updateDetailPanel(); updateTowerButtons();
        }

        function updateDetailPanel() {
            const t = gameState.selectedPlacedTower; if (!t) return;
            const upgCost = Math.floor(t.baseCost * 0.8); const sellCost = Math.floor(t.baseCost * 0.6);
            const panel = document.getElementById('detail-panel');
            panel.innerHTML = `<div class="detail-title"><span>${t.icon} ${t.name}</span><span>Lv.${t.level}</span></div><div class="detail-row"><span>傷害:</span><span>${t.damage}</span></div><div class="detail-row"><span>範圍:</span><span>${Math.floor(t.range)}</span></div><div class="detail-desc">已佈署的武將。</div>`;
            document.getElementById('action-area').classList.remove('hidden');
            document.getElementById('cost-upg').textContent = `(${upgCost})`; document.getElementById('cost-sell').textContent = `(${sellCost})`;
            document.getElementById('btn-upgrade').disabled = gameState.gold < upgCost;
        }

        function deselectAll() {
            gameState.selectedTowerType = null; gameState.selectedPlacedTower = null;
            document.getElementById('detail-panel').innerHTML = `<div style="text-align: center; color: #757575; padding-top: 40px;">選擇武將查看詳情</div>`;
            document.getElementById('action-area').classList.add('hidden'); updateTowerButtons();
        }

        function updateTowerButtons() {
            const btns = document.querySelectorAll('.tower-btn');
            btns.forEach((btn, idx) => {
                const gen = gameState.factionData.generals[idx];
                btn.className = 'tower-btn';
                if (gameState.selectedTowerType === idx) btn.classList.add('selected');
                if (gameState.gold < gen.cost) btn.classList.add('disabled');
            });
        }

        function actionUpgrade() { if (gameState.selectedPlacedTower) gameState.selectedPlacedTower.upgrade(); }
        function actionSell() {
            if (gameState.selectedPlacedTower) {
                const t = gameState.selectedPlacedTower; gameState.gold += Math.floor(t.baseCost * 0.6);
                const idx = gameState.towers.indexOf(t); if (idx > -1) gameState.towers.splice(idx, 1);
                createParticles(t.x, t.y, '#9e9e9e'); deselectAll(); updateStatsUI();
            }
        }

        function updateStatsUI() {
            document.getElementById('wave-display').textContent = `${gameState.wave}/5`;
            document.getElementById('lives-display').textContent = gameState.lives;
            document.getElementById('gold-display').textContent = gameState.gold;
            updateTowerButtons(); if (gameState.selectedPlacedTower) updateDetailPanel();
            const startBtn = document.getElementById('start-btn');
            if (gameState.active || gameState.spawning) { startBtn.disabled = true; startBtn.textContent = "戰鬥中..."; startBtn.style.backgroundColor = '#757575'; }
            else {
                startBtn.disabled = false;
                startBtn.textContent = gameState.wave === 0 ? "開始戰鬥" : (gameState.wave === 4 ? "BOSS 來襲！" : "下一波");
                startBtn.style.backgroundColor = gameState.wave === 4 ? '#b71c1c' : 'var(--accent-color)';
            }
        }

        function startNextWave() {
            if (gameState.active) return;
            gameState.active = true; gameState.wave++; gameState.spawning = true;
            gameState.enemiesToSpawn = generateWaveComposition(gameState.wave);
            gameState.spawnTimer = 0; updateStatsUI();
        }

        function generateWaveComposition(wave) {
            let list = []; const diff = gameState.difficultyLevel;
            if (wave === 5) {
                list.push('boss');
                for(let i=0; i<6; i++) { if (diff >= 4) list.push('general'); else list.push(Math.random()>0.5 ? 'heavy' : 'taoist'); }
            } else {
                let count = 5 + (wave * 2) + Math.floor(diff * 1.5);
                for(let i=0; i<count; i++) {
                    let r = Math.random(); let type = 'soldier';
                    if (diff >= 2 && r < 0.25) type = 'cavalry'; if (diff >= 3 && r < 0.2) type = 'scout';
                    if (diff >= 4 && r < 0.15) type = 'taoist'; if (diff >= 5 && r < 0.15) type = 'heavy';
                    if (diff >= 7 && r < 0.05) type = 'general';
                    list.push(type);
                }
            }
            return list;
        }

        function update() {
            if (gameState.gameOver || !gameState.active) return;
            if (gameState.spawning) {
                gameState.spawnTimer++; let interval = 40; if(gameState.wave === 5) interval = 60;
                if (gameState.spawnTimer > interval) {
                    if (gameState.enemiesToSpawn.length > 0) {
                        const randPath = gameState.allPaths[Math.floor(Math.random() * gameState.allPaths.length)];
                        gameState.enemies.push(new Enemy(gameState.enemiesToSpawn.shift(), gameState.difficultyLevel, randPath));
                        gameState.spawnTimer = 0;
                    } else { gameState.spawning = false; }
                }
            }
            for (let i = gameState.enemies.length - 1; i >= 0; i--) { const e = gameState.enemies[i]; e.update(); if (e.hp <= 0) gameState.enemies.splice(i, 1); }
            gameState.towers.forEach(t => t.update());
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const p = gameState.projectiles[i]; if (!p.active) { gameState.projectiles.splice(i, 1); continue; }
                if (p.type === 'line') {
                    p.x += Math.cos(p.angle) * p.speed; p.y += Math.sin(p.angle) * p.speed;
                    p.life--; if (p.life <= 0) p.active = false;
                    gameState.enemies.forEach(e => { if (Math.hypot(e.x - p.x, e.y - p.y) < e.radius + 5) { e.takeDamage(p.damage); createParticles(e.x, e.y, p.color); }});
                } else {
                    if (p.target.hp <= 0) { p.active = false; continue; }
                    const dx = p.target.x - p.x; const dy = p.target.y - p.y; const dist = Math.hypot(dx, dy);
                    if (dist < p.speed) {
                        p.active = false; const targets = [];
                        if (p.type === 'splash' || p.type === 'magic') gameState.enemies.forEach(e => { if (Math.hypot(e.x - p.target.x, e.y - p.target.y) < (p.type==='splash'?60:50)) targets.push(e); });
                        else targets.push(p.target);
                        targets.forEach(e => {
                            e.takeDamage(p.damage);
                            if (p.effect === 'slow') e.frozenTimer = 90; if (p.effect === 'stun') e.stunTimer = 30; if (p.effect === 'burn') e.burnTimer = 120;
                        });
                        createParticles(p.target.x, p.target.y, p.color);
                    } else { p.x += (dx/dist)*p.speed; p.y += (dy/dist)*p.speed; }
                }
            }
            for (let i = gameState.particles.length - 1; i >= 0; i--) { gameState.particles[i].update(); if (gameState.particles[i].life <= 0) gameState.particles.splice(i, 1); }
            if (!gameState.spawning && gameState.enemies.length === 0) {
                gameState.active = false;
                if (gameState.wave === 5) {
                    const bonus = 250 + (gameState.difficultyLevel * 50);
                    document.getElementById('level-reward').textContent = `獎勵: ${bonus} 庫銀 (庫銀將保留至下一關)`;
                    document.getElementById('level-screen').classList.remove('hidden');
                } else {
                    gameState.gold += 50 + (gameState.difficultyLevel * 10); updateStatsUI();
                }
            }
        }

        function draw() {
            ctx.fillStyle = gameState.factionData ? gameState.factionData.bgColor : '#1a100e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!gameState.factionData) return;
            gameState.decorations.forEach(d => {
                ctx.save(); ctx.translate(d.x, d.y); ctx.scale(d.scale, d.scale); ctx.rotate(d.rotation);
                ctx.font = '24px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(d.icon, 0, 0); ctx.restore();
            });
            ctx.lineWidth = 30; ctx.lineCap = 'round'; ctx.lineJoin = 'round'; ctx.strokeStyle = 'rgba(0,0,0,0.15)';
            gameState.allPaths.forEach(path => {
                ctx.beginPath(); if (path.length > 0) { ctx.moveTo(path[0].x, path[0].y); for(let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y); } ctx.stroke();
            });
            gameState.towers.forEach(t => t.draw()); gameState.enemies.forEach(e => e.draw());
            gameState.projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, Math.PI*2); ctx.fill(); });
            gameState.particles.forEach(p => p.draw());
            if (gameState.selectedTowerType !== null && gameState.factionData) {
                const c = Math.floor(gameState.mouseX / GRID_SIZE); const r = Math.floor(gameState.mouseY / GRID_SIZE);
                if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                    const x = c * GRID_SIZE + GRID_SIZE/2; const y = r * GRID_SIZE + GRID_SIZE/2;
                    const gen = gameState.factionData.generals[gameState.selectedTowerType]; const base = ARCHETYPES[gen.base];
                    ctx.globalAlpha = 0.5; ctx.fillStyle = isPath(c,r) ? '#ef5350' : gen.color;
                    ctx.beginPath(); ctx.arc(x, y, 15, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(x, y, base.range, 0, Math.PI*2); ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
            }
        }

        canvas.addEventListener('click', (e) => {
            if (gameState.gameOver || !gameState.factionData) return;
            const rect = canvas.getBoundingClientRect();
            const c = Math.floor((e.clientX - rect.left) / GRID_SIZE); const r = Math.floor((e.clientY - rect.top) / GRID_SIZE);
            if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return;
            const clicked = gameState.towers.find(t => t.c === c && t.r === r);
            if (clicked) { selectPlacedTower(clicked); return; }
            if (gameState.selectedTowerType !== null) {
                if (isPath(c, r)) return;
                const gen = gameState.factionData.generals[gameState.selectedTowerType];
                if (gameState.gold >= gen.cost) {
                    gameState.gold -= gen.cost; gameState.towers.push(new Tower(c, r, gameState.selectedTowerType));
                    createParticles(c*GRID_SIZE+20, r*GRID_SIZE+20, '#fff'); updateStatsUI();
                }
            } else { deselectAll(); }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect(); gameState.mouseX = e.clientX - rect.left; gameState.mouseY = e.clientY - rect.top;
        });

        function isPath(c, r) { return gameState.roadTiles.some(t => Math.floor(t.x/GRID_SIZE) === c && Math.floor(t.y/GRID_SIZE) === r); }
        function createParticles(x, y, color) { for(let i=0; i<6; i++) gameState.particles.push(new Particle(x, y, color)); }
        class Particle {
            constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.life = 20; this.vx = (Math.random()-0.5)*4; this.vy = (Math.random()-0.5)*4; }
            update() { this.x+=this.vx; this.y+=this.vy; this.life--; }
            draw() { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, 3, 3); }
        }
        function gameOver() {
            gameState.gameOver = true; gameState.active = false;
            document.getElementById('end-screen').classList.remove('hidden');
            document.getElementById('end-desc').textContent = `你的霸業在第 ${gameState.difficultyLevel} 關，第 ${gameState.wave} 波結束了。`;
        }
        function gameLoop() { update(); draw(); if (!gameState.gameOver) requestAnimationFrame(gameLoop); }
        draw(); 
    </script>
</body>
</html>