<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>三國の演義：無限戰役 </title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap');

        :root {
            --bg-color: #f4e4bc;
            --panel-color: #3e2723;
            --text-color: #f4e4bc;
            --accent-color: #d32f2f;
            --shu-color: #2e7d32;
            --wei-color: #1565c0;
            --wu-color: #c62828;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; padding: 0;
            background-color: #1a100e;
            font-family: 'Noto Serif TC', serif, "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; width: 100vw; overflow: hidden;
            color: #333; user-select: none; -webkit-user-select: none;
        }

        #game-wrapper {
            position: relative;
            width: 100%; height: 100%;
            max-width: 1400px;
            background-color: var(--bg-color);
            border: 2px solid var(--panel-color);
            display: flex;
            flex-direction: column; 
            overflow: hidden;
        }

        /* --- Screens --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; transition: opacity 0.3s; padding: 20px; text-align: center;
        }
        .hidden { display: none !important; opacity: 0; }

        #splash-screen { background: radial-gradient(circle, #3e2723 0%, #1a100e 100%); z-index: 110; }
        .enter-btn {
            background: var(--accent-color); border: 2px solid #ffb74d; color: white;
            padding: 20px 50px; font-size: 28px; font-family: inherit; font-weight: bold;
            border-radius: 50px; cursor: pointer; box-shadow: 0 0 20px var(--accent-color);
            transition: all 0.3s; margin-top: 30px;
        }
        .enter-btn:hover { transform: scale(1.1); box-shadow: 0 0 40px var(--accent-color); }

        .faction-select { display: flex; gap: 15px; margin-top: 20px; flex-wrap: wrap; justify-content: center; overflow-y: auto; }
        .faction-card {
            width: 160px; height: 260px; border: 3px solid #555; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s; background: rgba(255,255,255,0.1);
        }
        .faction-card:active { transform: scale(0.95); }
        .faction-symbol { font-size: 60px; margin-bottom: 10px; }
        .faction-name { font-size: 24px; font-weight: bold; }
        
        /* UI Layout */
        .canvas-container {
            flex: 1.2; position: relative; background-color: #dccbba;
            display: flex; justify-content: center; align-items: center; min-height: 0; overflow: hidden;
        }
        #game-canvas { max-width: 100%; max-height: 100%; object-fit: contain; }

        #ui-sidebar {
            flex: 1; background-color: var(--panel-color); color: var(--text-color);
            display: flex; flex-direction: column; border-top: 4px solid #1a100e; padding: 8px; min-height: 0; 
        }

        @media (orientation: landscape) or (min-width: 1024px) {
            #game-wrapper { flex-direction: row; }
            .canvas-container { flex: 3; }
            #ui-sidebar { flex: 0 0 320px; border-top: none; border-left: 4px solid #1a100e; }
        }

        .scrollable-content { flex: 1; overflow-y: auto; padding-right: 4px; }
        .fixed-bottom { flex-shrink: 0; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); }

        .stats-panel {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px;
            background: rgba(0,0,0,0.3); padding: 6px; border-radius: 4px; margin-bottom: 8px;
        }
        .stat-item { display: flex; flex-direction: column; align-items: center; }
        .stat-label { font-size: 10px; opacity: 0.8; }
        .stat-value { font-size: 15px; font-weight: bold; color: #ffb74d; }

        .tower-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; margin-bottom: 8px; }
        .tower-btn {
            display: flex; flex-direction: column; align-items: center; background-color: #4e342e;
            border: 2px solid #6d4c41; padding: 4px; border-radius: 4px; min-height: 55px; justify-content: center;
        }
        .tower-btn.selected { background-color: #1b5e20; border-color: #66bb6a; }
        .tower-btn.disabled { opacity: 0.4; filter: grayscale(1); }
        .tower-icon-display { font-size: 20px; }
        .tower-name { font-size: 11px; font-weight: bold; }
        .tower-cost { font-size: 10px; color: #ffcc80; }

        #detail-panel { background: rgba(0,0,0,0.3); border: 1px solid #8d6e63; padding: 12px; border-radius: 4px; font-size: 12px; margin-bottom: 5px; }
        .detail-title { color: #ffb74d; font-weight: bold; border-bottom: 1px solid #5d4037; padding-bottom: 4px; margin-bottom: 8px; display: flex; justify-content: space-between; }
        .detail-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px 12px; text-align: center; }
        .detail-item { display: flex; flex-direction: column; align-items: center; border: 1px solid rgba(255,255,255,0.05); padding: 4px; border-radius: 4px; background: rgba(0,0,0,0.1); }
        .detail-label { color: #aaa; font-size: 9px; margin-bottom: 2px; }
        .detail-val { color: #fff; font-weight: bold; font-size: 13px; }
        .upgrade-preview { color: #81c784; font-size: 11px; margin-top: 10px; border-top: 1px dashed #5d4037; padding-top: 8px; text-align: center; }
        .upgrade-hint { font-size: 10px; color: #ffcc80; margin-top: 5px; text-align: center; opacity: 0.8; }

        #start-btn {
            width: 100%; padding: 12px; font-family: inherit; font-size: 18px; font-weight: bold;
            background-color: var(--accent-color); color: white; border: none; border-radius: 4px; 
            box-shadow: 0 4px #b71c1c; cursor: pointer;
        }
        #start-btn:active { transform: translateY(2px); box-shadow: 0 2px #b71c1c; }
        #start-btn:disabled { background-color: #555; box-shadow: none; opacity: 0.6; }

        #sound-btn {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0,0,0,0.6); border: 1px solid #ffb74d; color: #ffb74d;
            width: 36px; height: 36px; border-radius: 50%; z-index: 200;
            display: flex; justify-content: center; align-items: center; cursor: pointer;
        }
        #bgm-name { position: absolute; bottom: 10px; right: 10px; color: rgba(255, 255, 255, 0.4); font-size: 10px; pointer-events: none; opacity: 0; transition: opacity 0.5s; }
    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="splash-screen" class="screen">
            <h1 style="font-size: 42px; color: #ffb74d; border:none; text-shadow: 0 0 20px #000;">三國：群雄割據</h1>
            <p style="color: #ccc; margin-bottom: 20px;">15首戰場名曲 · 無限Roguelike戰役</p>
            <button class="enter-btn" onclick="activateAudio()">進入戰場</button>
        </div>

        <button id="sound-btn" onclick="toggleSound()">🔊</button>
        <div id="bgm-name"></div>

        <div id="menu-screen" class="screen hidden">
            <h1 style="font-size: 32px; border: none; margin: 0; color: #ffb74d;">選擇陣營</h1>
            <div class="faction-select">
                <div class="faction-card faction-shu" onclick="startGame('shu')">
                    <div class="faction-symbol" style="color: var(--shu-color)">蜀</div>
                    <div class="faction-name">蜀漢</div>
                </div>
                <div class="faction-card faction-wei" onclick="startGame('wei')">
                    <div class="faction-symbol" style="color: var(--wei-color)">魏</div>
                    <div class="faction-name">曹魏</div>
                </div>
                <div class="faction-card faction-wu" onclick="startGame('wu')">
                    <div class="faction-symbol" style="color: var(--wu-color)">吳</div>
                    <div class="faction-name">東吳</div>
                </div>
            </div>
        </div>

        <div id="level-screen" class="screen hidden">
            <h2 id="level-title">大獲全勝</h2>
            <p id="level-reward" style="color: #81c784; font-size: 20px;"></p>
            <button class="next-btn" onclick="nextLevel()">繼續進軍</button>
        </div>
        <div id="end-screen" class="screen hidden">
            <h2 id="end-title">城池失守</h2>
            <p id="end-desc"></p>
            <button class="next-btn" onclick="location.reload()" style="background: var(--accent-color); border:none;">返回標題</button>
        </div>

        <div class="canvas-container">
            <canvas id="game-canvas" width="880" height="700"></canvas>
        </div>
        
        <aside id="ui-sidebar">
            <div class="header-info">
                <span id="faction-label">陣營</span>
                <span id="map-label">關卡: 1</span>
            </div>
            <div class="stats-panel">
                <div class="stat-item"><span class="stat-label">波次</span><span id="wave-display" class="stat-value">0/5</span></div>
                <div class="stat-item"><span class="stat-label">耐久</span><span id="lives-display" class="stat-value" style="color: #ef5350;">20</span></div>
                <div class="stat-item"><span class="stat-label">庫銀</span><span id="gold-display" class="stat-value" style="color: #ffd700;">150</span></div>
            </div>
            <div class="scrollable-content">
                <div id="tower-grid" class="tower-grid"></div>
                <div id="detail-panel"><div style="text-align: center; color: #757575; padding: 20px;">選擇武將查看詳情</div></div>
                <p class="upgrade-hint">💡 提示：點擊地圖上已部署的武將進行晉升或撤退</p>
                <div id="action-area" class="action-row hidden">
                    <div style="display: flex; gap: 8px; margin-top: 10px;">
                        <button id="btn-upgrade" class="btn-mini btn-upg" onclick="actionUpgrade()">晉升 <span id="cost-upg"></span></button>
                        <button id="btn-sell" class="btn-mini btn-sell" onclick="actionSell()">撤退</button>
                    </div>
                </div>
            </div>
            <div class="fixed-bottom">
                <button id="start-btn" onclick="startNextWave()">開始戰鬥</button>
            </div>
        </aside>
    </div>

    <script>
        // --- High Power Audio System (15 Tracks) ---
        class SoundManager {
            constructor() {
                this.ctx = null; this.muted = false; this.masterGain = null;
                this.isPlayingBGM = false; this.nextNoteTime = 0; this.beatCount = 0;
                this.currentTrack = 'ambush';
                this.tracks = {
                    'ambush': { name: '十面埋伏', tempo: 155, logic: this.bgmAmbush.bind(this) },
                    'general': { name: '將軍令', tempo: 105, logic: this.bgmGeneral.bind(this) },
                    'lone': { name: '千里走單騎', tempo: 135, logic: this.bgmLone.bind(this) },
                    'empty': { name: '空城計', tempo: 75, logic: this.bgmEmpty.bind(this) },
                    'cliff': { name: '赤壁以此', tempo: 165, logic: this.bgmCliff.bind(this) },
                    'peach': { name: '桃園結義', tempo: 110, logic: this.bgmPeach.bind(this) },
                    'march': { name: '中原逐鹿', tempo: 125, logic: this.bgmMarch.bind(this) },
                    'strategy': { name: '運籌帷幄', tempo: 95, logic: this.bgmStrategy.bind(this) },
                    'siege': { name: '兵臨城下', tempo: 145, logic: this.bgmSiege.bind(this) },
                    'dragon': { name: '臥龍升天', tempo: 130, logic: this.bgmDragon.bind(this) },
                    // New Mongolian Tracks
                    'khoomei': { name: '呼麥低吟', tempo: 80, logic: this.bgmKhoomei.bind(this) },
                    'hooves': { name: '鐵騎踏破', tempo: 180, logic: this.bgmHooves.bind(this) },
                    'khagan': { name: '大汗令', tempo: 100, logic: this.bgmKhagan.bind(this) },
                    'storm': { name: '北疆風暴', tempo: 160, logic: this.bgmStorm.bind(this) },
                    'horde': { name: '金帳盛宴', tempo: 120, logic: this.bgmHorde.bind(this) }
                };
            }
            init() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.connect(this.ctx.destination);
                    this.masterGain.gain.value = 1.0; 
                }
                if (this.ctx.state === 'suspended') this.ctx.resume();
                this.startBGM();
            }
            toggle() {
                if (!this.ctx) { this.init(); return; }
                this.muted = !this.muted;
                if(this.muted) { this.ctx.suspend(); this.isPlayingBGM = false; }
                else { this.ctx.resume(); this.startBGM(); }
                document.getElementById('sound-btn').textContent = this.muted ? '🔇' : '🔊';
            }
            selectRandomTrack() {
                const keys = Object.keys(this.tracks);
                this.currentTrack = keys[Math.floor(Math.random() * keys.length)];
                const display = document.getElementById('bgm-name');
                if (display) {
                    display.textContent = `♪ ${this.tracks[this.currentTrack].name}`;
                    display.style.opacity = 1;
                    setTimeout(() => display.style.opacity = 0, 5000);
                }
            }
            startBGM() {
                if (this.isPlayingBGM) return;
                this.isPlayingBGM = true; this.nextNoteTime = this.ctx.currentTime + 0.1;
                this.beatCount = 0; this.scheduler();
            }
            scheduler() {
                if (!this.isPlayingBGM || this.muted) return;
                const track = this.tracks[this.currentTrack];
                while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                    track.logic(this.beatCount, this.nextNoteTime);
                    this.nextNoteTime += 15.0 / track.tempo; 
                    this.beatCount++;
                }
                setTimeout(() => this.scheduler(), 25);
            }
            triggerDrum(t, f, v) {
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(f, t);
                osc.frequency.exponentialRampToValueAtTime(10, t + 0.2);
                g.gain.setValueAtTime(v * 0.8, t); g.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.connect(g); g.connect(this.masterGain); osc.start(t); osc.stop(t + 0.2);
            }
            triggerPipa(t, f, d, v=0.3) {
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(f, t);
                g.gain.setValueAtTime(v, t); g.gain.exponentialRampToValueAtTime(0.01, t + d);
                osc.connect(g); g.connect(this.masterGain); osc.start(t); osc.stop(t + d);
            }
            triggerHorse(t, v) {
                // Morin Khuur-like staccato bow sound
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(110, t);
                g.gain.setValueAtTime(v, t); g.gain.linearRampToValueAtTime(0, t + 0.05);
                osc.connect(g); g.connect(this.masterGain); osc.start(t); osc.stop(t + 0.05);
            }
            // TRACKS LOGIC
            bgmAmbush(b, t) { if (b % 2 === 0) this.triggerPipa(t, 330, 0.1); if (b % 8 === 0) this.triggerDrum(t, 60, 1.2); }
            bgmGeneral(b, t) { if (b % 4 === 0) this.triggerDrum(t, 50, 1.3); if (b % 8 === 4) this.triggerDrum(t, 80, 0.9); }
            bgmLone(b, t) { if (b % 3 === 0) this.triggerDrum(t, 100, 0.8); }
            bgmEmpty(b, t) { if (b % 16 === 0) this.triggerPipa(t, 660, 0.5); }
            bgmCliff(b, t) { if (b % 2 === 0) this.triggerDrum(t, 70, 0.9); }
            bgmPeach(b, t) { if (b % 8 === 0) this.triggerPipa(t, 440, 0.4); }
            bgmMarch(b, t) { if (b % 4 === 0) this.triggerDrum(t, 90, 1.0); }
            bgmStrategy(b, t) { if (b % 16 === 0) this.triggerPipa(t, 220, 1.2); }
            bgmSiege(b, t) { if (b % 2 === 0) this.triggerDrum(t, 60, 0.9); }
            bgmDragon(b, t) { if (b % 4 === 0) this.triggerDrum(t, 120, 1.0); }
            // MONGOLIAN TRACKS
            bgmKhoomei(b, t) { if(b%16===0) this.triggerDrum(t, 40, 1.0); if(b%32<8) this.triggerPipa(t, 110, 0.2, 0.5); }
            bgmHooves(b, t) { if(b%3===0) this.triggerDrum(t, 80, 0.8); if(b%3===1) this.triggerClick(t, 0.1); }
            bgmKhagan(b, t) { if(b%4===0) this.triggerDrum(t, 50, 1.4); if(b%8===2) this.triggerGong(t, 0.2); }
            bgmStorm(b, t) { if(Math.random()>0.8) this.triggerNoise(t, 0.2, 0.1); if(b%4===0) this.triggerHorse(t, 0.3); }
            bgmHorde(b, t) { if(b%8<4) this.triggerPipa(t, [330, 392, 440][b%3], 0.1, 0.3); if(b%4===0) this.triggerDrum(t, 100, 0.8); }

            triggerGong(t, v) { this.triggerPipa(t, 150, 0.8, v); }
            triggerNoise(t, d, v) { /* simplified white noise burst */ }
            triggerClick(t, v) { this.triggerPipa(t, 1200, 0.05, v); }

            playShoot() { if(!this.muted && this.ctx) this.triggerPipa(this.ctx.currentTime, 800, 0.05, 0.2); }
            playHit() { if(!this.muted && this.ctx) this.triggerDrum(this.ctx.currentTime, 60, 0.5); }
            playBuild() { if(!this.muted && this.ctx) this.triggerPipa(this.ctx.currentTime, 523, 0.2, 0.5); }
            playSell() { if(!this.muted && this.ctx) this.triggerDrum(this.ctx.currentTime, 200, 0.4); }
            playWin() { if(!this.muted && this.ctx) this.triggerPipa(this.ctx.currentTime, 1046, 0.5, 0.6); }
            playLose() { if(!this.muted && this.ctx) this.triggerDrum(this.ctx.currentTime, 40, 1.2); }
        }

        const soundManager = new SoundManager();
        function toggleSound() { soundManager.toggle(); }
        function activateAudio() {
            soundManager.init();
            document.getElementById('splash-screen').classList.add('hidden');
            document.getElementById('menu-screen').classList.remove('hidden');
        }

        // --- Game Logic ---
        const ARCHETYPES = {
            'archer': { type: 'single', range: 180, damage: 15, cooldown: 25, nameType: '神射', desc: '射程遠，攻速中等' },
            'fast':   { type: 'single', range: 130, damage: 8, cooldown: 10, nameType: '突擊', desc: '攻速極快，低傷害' },
            'heavy':  { type: 'single', range: 120, damage: 60, cooldown: 55, nameType: '重擊', desc: '攻擊高，攻速慢' },
            'line':   { type: 'line', range: 150, damage: 12, cooldown: 40, nameType: '穿透', desc: '直線貫穿多個敵人' },
            'splash': { type: 'splash', range: 110, damage: 40, cooldown: 60, nameType: '範圍', desc: '造成小範圍爆炸傷害' },
            'magic':  { type: 'magic', range: 160, damage: 20, cooldown: 50, nameType: '法術', desc: '範圍傷害並附加異常狀態' }
        };

        const FACTIONS = {
            'shu': { name: '蜀漢', color: '#2e7d32', bgColor: '#d7ccc8', mapPrefixes: ['劍閣', '漢中', '祁山'], generals: [
                { name: '黃忠', icon: '\u{1F3F9}', cost: 60, base: 'archer', stats: { range: 230 } },
                { name: '趙雲', icon: '\u{26A1}', cost: 90, base: 'fast', stats: { cooldown: 8 } },
                { name: '關羽', icon: '\u{1F5E1}', cost: 120, base: 'heavy', stats: { damage: 85 } },
                { name: '馬超', icon: '\u{1F40E}', cost: 140, base: 'line', stats: { damage: 15 } },
                { name: '張飛', icon: '\u{1F4A5}', cost: 180, base: 'splash', stats: { range: 130 } },
                { name: '諸葛亮', icon: '\u{262F}', cost: 250, base: 'magic', effect: 'slow', stats: { cooldown: 40 } }
            ], decorations: ['\u{1F332}', '\u{1FAA8}'] },
            'wei': { name: '曹魏', color: '#1565c0', bgColor: '#cfd8dc', mapPrefixes: ['許昌', '合肥', '樊城'], generals: [
                { name: '夏侯淵', icon: '\u{1F3F9}', cost: 60, base: 'archer', stats: { cooldown: 20 } },
                { name: '張遼', icon: '\u{2694}', cost: 90, base: 'fast', stats: { damage: 10 } },
                { name: '夏侯惇', icon: '\u{1F441}', cost: 120, base: 'heavy', stats: { cooldown: 45 } },
                { name: '徐晃', icon: '\u{1FA93}', cost: 140, base: 'line', stats: { range: 170 } },
                { name: '典韋', icon: '\u{1F4AA}', cost: 180, base: 'splash', stats: { damage: 50, splashRadius: 80 } },
                { name: '司馬懿', icon: '\u{1F52E}', cost: 250, base: 'magic', effect: 'stun', stats: { damage: 30 } }
            ], decorations: ['\u{1F9F1}', '\u{1F3DA}'] },
            'wu': { name: '東吳', color: '#c62828', bgColor: '#b3e5fc', mapPrefixes: ['赤壁', '夷陵', '建業'], generals: [
                { name: '孫尚香', icon: '\u{1F3F9}', cost: 60, base: 'archer', stats: { cooldown: 18, damage: 11 } },
                { name: '甘寧', icon: '\u{1F514}', cost: 90, base: 'fast', effect: 'burn' },
                { name: '太史慈', icon: '\u{1F6E1}', cost: 120, base: 'heavy', stats: { range: 140 } },
                { name: '凌統', icon: '\u{1F531}', cost: 140, base: 'line', stats: { cooldown: 30 } },
                { name: '黃蓋', icon: '\u{1F4A3}', cost: 180, base: 'splash', stats: { damage: 30, cooldown: 40 } },
                { name: '周瑜', icon: '\u{1F525}', cost: 250, base: 'magic', effect: 'burn', stats: { damage: 45 } }
            ], decorations: ['\u{1F343}', '\u{1F41F}'] }
        };

        const GRID_SIZE = 40; const COLS = 22; const ROWS = 17;
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        let gameState = {
            activeFaction: null, factionData: null, difficultyLevel: 1, 
            towers: [], enemies: [], projectiles: [], particles: [],
            gold: 150, lives: 20, wave: 0, active: false, spawning: false,
            enemiesToSpawn: [], spawnTimer: 0,
            selectedTowerType: null, selectedPlacedTower: null, gameOver: false,
            allPaths: [], roadTiles: [], decorations: [], mouseX: 0, mouseY: 0
        };

        function startGame(factionKey) {
            gameState.activeFaction = factionKey; gameState.factionData = FACTIONS[factionKey];
            gameState.difficultyLevel = 1; gameState.gold = 150;
            document.getElementById('menu-screen').classList.add('hidden');
            const facLab = document.getElementById('faction-label');
            if(facLab) { facLab.textContent = gameState.factionData.name; facLab.style.color = gameState.factionData.color; }
            setupTowerButtons(); generateMap(); resetSession(150); gameLoop();
        }

        function generateMap() {
            soundManager.selectRandomTrack();
            const f = gameState.factionData;
            const titleEl = document.getElementById('faction-title');
            if(titleEl) titleEl.textContent = f.mapPrefixes[Math.floor(Math.random()*f.mapPrefixes.length)] + "前線";
            const mapLab = document.getElementById('map-label');
            if(mapLab) mapLab.textContent = `關卡: ${gameState.difficultyLevel}`;

            const startY = 3 + Math.floor(Math.random()*(ROWS-6));
            const endY = 3 + Math.floor(Math.random()*(ROWS-6));
            let mainPathGrid = createPathGrid({x: 0, y: startY}, {x: COLS-1, y: endY});
            gameState.allPaths = [mainPathGrid.map(p => ({x: p.x*GRID_SIZE+20, y: p.y*GRID_SIZE+20}))];
            
            const roadTileSet = new Set();
            mainPathGrid.forEach(t => roadTileSet.add(`${t.x},${t.y}`));
            gameState.roadTiles = []; 
            roadTileSet.forEach(s => { let [x,y] = s.split(',').map(Number); gameState.roadTiles.push({x: x*GRID_SIZE+20, y: y*GRID_SIZE+20}); });
            generateDecorations(roadTileSet);
        }

        function createPathGrid(s, e) {
            let p = []; let c = {...s}; p.push({...c});
            let mX = Math.floor(COLS/2);
            while(c.x < mX) { c.x++; p.push({...c}); }
            while(c.y !== e.y) { c.y += (c.y < e.y ? 1 : -1); p.push({...c}); }
            while(c.x < e.x) { c.x++; p.push({...c}); }
            return p;
        }

        function generateDecorations(road) {
            gameState.decorations = [];
            for(let i=0; i<45; i++) {
                let c = Math.floor(Math.random()*COLS); let r = Math.floor(Math.random()*ROWS);
                if(!road.has(`${c},${r}`)) {
                    gameState.decorations.push({x: c*40+20, y: r*40+20, icon: gameState.factionData.decorations[Math.floor(Math.random()*2)], rot: Math.random()*7});
                }
            }
        }

        function setupTowerButtons() {
            const grid = document.getElementById('tower-grid'); if(!grid) return;
            grid.innerHTML = '';
            gameState.factionData.generals.forEach((g, i) => {
                const btn = document.createElement('div'); btn.className = 'tower-btn'; btn.onclick = () => selectTowerType(i);
                btn.innerHTML = `<div class="tower-icon-display">${g.icon}</div><div class="tower-name">${g.name}</div><div class="tower-cost">💰${g.cost}</div>`;
                grid.appendChild(btn);
            });
        }

        function resetSession(g) {
            gameState.gold = g; gameState.lives = 20; gameState.wave = 0;
            gameState.towers = []; gameState.enemies = []; gameState.projectiles = []; gameState.particles = [];
            gameState.active = false; gameState.spawning = false; gameState.gameOver = false;
            deselectAll(); updateStatsUI();
        }

        class Enemy {
            constructor(type, diff, path, wave) {
                this.path = path; this.idx = 0; this.x = path[0].x; this.y = path[0].y;
                const finalMult = Math.pow(1.35, diff-1) * (1 + wave*0.12);
                const rMult = Math.pow(1.18, diff-1);
                this.baseHp = type==='boss'?900:type==='heavy'?140:45;
                this.speed = type==='boss'?0.6:type==='scout'?2.8:1.8;
                this.icon = type==='boss'?'\u{1F479}':type==='scout'?'\u{1F406}':'\u{1F482}';
                this.maxHp = Math.floor(this.baseHp * finalMult); this.hp = this.maxHp;
                this.gold = Math.floor((type==='boss'?350:10) * rMult);
                this.froz = 0; this.burn = 0; this.slowF = 1;
            }
            update() {
                let s = this.speed * (this.froz > 0 ? this.slowF : 1);
                if(this.burn > 0) { if(gameState.spawnTimer%25===0) this.takeDamage(4); this.burn--; }
                if(this.froz > 0) this.froz--;
                const t = this.path[this.idx+1];
                if(t) {
                    const dx = t.x-this.x; const dy = t.y-this.y; const d = Math.hypot(dx,dy);
                    if(d < s) { this.x=t.x; this.y=t.y; this.idx++; if(this.idx>=this.path.length-1) this.reachEnd(); }
                    else { this.x += (dx/d)*s; this.y += (dy/d)*s; }
                }
            }
            draw() {
                ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.arc(this.x, this.y, 14, 0, 7); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.font = '18px Arial'; ctx.textAlign='center'; ctx.fillText(this.icon, this.x, this.y+7);
                ctx.fillStyle = '#333'; ctx.fillRect(this.x-12, this.y-18, 24, 3);
                ctx.fillStyle = 'lime'; ctx.fillRect(this.x-12, this.y-18, 24*(this.hp/this.maxHp), 3);
            }
            takeDamage(a) { this.hp -= a; if(this.hp<=0) { gameState.gold += this.gold; updateStatsUI(); soundManager.playHit(); return true; } return false; }
            reachEnd() { 
                gameState.lives--; updateStatsUI(); 
                if(gameState.lives <= 0) gameOver();
                else { this.idx = 0; this.x = this.path[0].x; this.y = this.path[0].y; }
            }
        }

        class Tower {
            constructor(c, r, gi) {
                this.c=c; this.r=r; this.x=c*40+20; this.y=r*40+20;
                const g = gameState.factionData.generals[gi]; const b = ARCHETYPES[g.base];
                const s = {...b, ...(g.stats||{})};
                this.name=g.name; this.icon=g.icon; this.color=g.color; this.level=1;
                this.dmg=s.damage; this.rng=s.range; this.cdM=s.cooldown; this.type=s.type;
                this.eff=g.effect||s.effect; this.cd=0; this.slowF=0.85; this.baseCost=g.cost;
                this.splashRadius = s.splashRadius || 60;
            }
            update() {
                if(this.cd > 0) this.cd--;
                let target = gameState.enemies.find(e => Math.hypot(e.x-this.x, e.y-this.y) <= this.rng);
                if(target && this.cd<=0) {
                    soundManager.playShoot();
                    gameState.projectiles.push({
                        x:this.x, y:this.y, target, dmg:this.dmg, color:this.color, type:this.type, 
                        eff:this.eff, slowF:this.slowF, active:true, 
                        angle: Math.atan2(target.y-this.y, target.x-this.x), 
                        splashRadius: this.splashRadius
                    });
                    this.cd = this.cdM;
                }
            }
            draw() {
                ctx.fillStyle = '#3e2723'; ctx.fillRect(this.x-16, this.y-16, 32, 32);
                if(gameState.selectedPlacedTower === this) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.rng, 0, Math.PI * 2); ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)'; ctx.fill();
                }
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x,this.y,15,0,7); ctx.fill();
                ctx.fillStyle='#fff'; ctx.font='18px Arial'; ctx.textAlign='center'; ctx.fillText(this.icon, this.x, this.y+7);
                if(this.level > 1) { ctx.fillStyle='#ffd700'; for(let i=0; i<this.level; i++) ctx.fillRect(this.x-10+(i*5), this.y-22, 3,3); }
            }
            upgrade() {
                const cost = Math.floor(this.baseCost*0.8);
                if(gameState.gold >= cost) {
                    gameState.gold -= cost; this.level++; 
                    this.dmg = Math.floor(this.dmg*1.4); this.rng = Math.floor(this.rng*1.1);
                    if(this.eff==='slow') this.slowF = Math.max(0.4, this.slowF-0.05);
                    this.baseCost += cost; soundManager.playBuild(); updateDetailPanel(); updateStatsUI();
                }
            }
        }

        function selectTowerType(i) {
            gameState.selectedTowerType=i; gameState.selectedPlacedTower=null;
            const g = gameState.factionData.generals[i]; const b = ARCHETYPES[g.base]; const s = {...b, ...(g.stats||{})};
            const detail = document.getElementById('detail-panel');
            if(detail) detail.innerHTML = `
                <div class="detail-title"><span>${g.icon} ${g.name}</span><span>💰${g.cost}</span></div>
                <div class="detail-grid">
                    <div class="detail-item"><span class="detail-label">攻擊</span><span class="detail-val">${s.damage}</span></div>
                    <div class="detail-item"><span class="detail-label">範圍</span><span class="detail-val">${s.range}</span></div>
                </div>
                <div class="detail-desc">${b.desc}</div>`;
            const act = document.getElementById('action-area'); if(act) act.classList.add('hidden');
            updateStatsUI();
        }

        function selectPlacedTower(t) {
            gameState.selectedPlacedTower=t; gameState.selectedTowerType=null; updateDetailPanel(); updateStatsUI();
        }

        function updateDetailPanel() {
            const t = gameState.selectedPlacedTower; if(!t) return;
            const detail = document.getElementById('detail-panel'); if(!detail) return;
            const upg = Math.floor(t.baseCost*0.8);
            detail.innerHTML = `
                <div class="detail-title"><span>${t.icon} ${t.name}</span><span>Lv.${t.level}</span></div>
                <div class="detail-grid">
                    <div class="detail-item"><span class="detail-label">傷害</span><span class="detail-val">${t.dmg}</span></div>
                    <div class="detail-item"><span class="detail-label">範圍</span><span class="detail-val">${t.rng}</span></div>
                </div>
                <div class="upgrade-preview">晉升: 傷害 ➤ ${Math.floor(t.dmg*1.4)}, 範圍 ➤ ${Math.floor(t.rng*1.1)}</div>`;
            const costUpg = document.getElementById('cost-upg'); if(costUpg) costUpg.textContent = `💰${upg}`;
            const act = document.getElementById('action-area'); if(act) act.classList.remove('hidden');
            const btnUpg = document.getElementById('btn-upgrade'); if(btnUpg) btnUpg.disabled = gameState.gold < upg;
        }

        function deselectAll() {
            gameState.selectedTowerType=null; gameState.selectedPlacedTower=null;
            const detail = document.getElementById('detail-panel');
            if(detail) detail.innerHTML = '<div style="text-align:center;color:#757575;padding:20px;">選擇武將查看詳情</div>';
            const act = document.getElementById('action-area'); if(act) act.classList.add('hidden');
            updateStatsUI();
        }

        function updateStatsUI() {
            const wav = document.getElementById('wave-display'); if(wav) wav.textContent = `${gameState.wave}/5`;
            const liv = document.getElementById('lives-display'); if(liv) liv.textContent = gameState.lives;
            const gol = document.getElementById('gold-display'); if(gol) gol.textContent = gameState.gold;
            const btns = document.querySelectorAll('.tower-btn');
            btns.forEach((b, i) => {
                b.classList.toggle('selected', gameState.selectedTowerType===i);
                if (gameState.factionData) b.classList.toggle('disabled', gameState.gold < gameState.factionData.generals[i].cost);
            });
            const s = document.getElementById('start-btn');
            if(s) {
                if(gameState.active) { s.disabled=true; s.textContent="進攻中..."; }
                else { s.disabled=false; s.textContent = gameState.wave===4 ? "BOSS 來襲" : "開始戰鬥"; }
            }
        }

        function startNextWave() {
            if(gameState.active) return;
            gameState.active=true; gameState.wave++; gameState.spawning=true;
            let count = 5 + gameState.wave*2;
            gameState.enemiesToSpawn = [];
            for(let i=0; i<count; i++) gameState.enemiesToSpawn.push(Math.random() > 0.8 ? 'scout' : (gameState.wave > 3 && Math.random() > 0.8 ? 'heavy' : 'soldier'));
            if(gameState.wave===5) gameState.enemiesToSpawn.push('boss');
            gameState.spawnTimer=0; updateStatsUI();
        }

        function nextLevel() {
            gameState.difficultyLevel++; generateMap();
            resetSession(gameState.gold + 250 + gameState.difficultyLevel*50);
            document.getElementById('level-screen').classList.add('hidden');
        }

        function gameOver() {
            soundManager.playLose(); gameState.gameOver=true;
            const end = document.getElementById('end-screen'); if(end) end.classList.remove('hidden');
            const desc = document.getElementById('end-desc'); if(desc) desc.textContent = `霸業在第 ${gameState.difficultyLevel} 關嘎然而止。`;
        }

        function update() {
            if(gameState.gameOver || !gameState.active) return;
            if(gameState.spawning) {
                gameState.spawnTimer++;
                if(gameState.spawnTimer > 40 && gameState.enemiesToSpawn.length > 0) {
                    gameState.enemies.push(new Enemy(gameState.enemiesToSpawn.shift(), gameState.difficultyLevel, gameState.allPaths[0], gameState.wave));
                    gameState.spawnTimer=0;
                } else if(gameState.enemiesToSpawn.length === 0) gameState.spawning=false;
            }
            gameState.enemies.forEach(e => e.update()); 
            gameState.enemies = gameState.enemies.filter(e => e.hp > 0);
            gameState.towers.forEach(t => t.update());
            gameState.projectiles.forEach(p => {
                if(!p.target || p.target.hp<=0) { p.active=false; return; }
                const dx = p.target.x-p.x; const dy = p.target.y-p.y; const d = Math.hypot(dx,dy);
                if(p.type === 'line') {
                    p.x += Math.cos(p.angle || 0) * 15; p.y += Math.sin(p.angle || 0) * 15;
                    gameState.enemies.forEach(e => { if(Math.hypot(e.x-p.x, e.y-p.y) < 15) e.takeDamage(p.dmg); });
                    if(p.x < 0 || p.x > 880 || p.y < 0 || p.y > 700) p.active=false;
                } else {
                    if(d < 12) {
                        p.active=false;
                        const targets = (p.type === 'splash' || p.type === 'magic') ? gameState.enemies.filter(e => Math.hypot(e.x - p.target.x, e.y - p.target.y) < (p.splashRadius||60)) : [p.target];
                        targets.forEach(e => {
                            e.takeDamage(p.dmg);
                            if(p.eff==='slow') { e.froz=90; e.slowF=p.slowF; }
                            if(p.eff==='burn') e.burn=120;
                            if(p.eff==='stun' && Math.random()>0.7) e.froz=30; 
                        });
                    } else { p.x += (dx/d)*12; p.y += (dy/d)*12; }
                }
            });
            gameState.projectiles = gameState.projectiles.filter(p => p.active);
            if(!gameState.spawning && gameState.enemies.length===0) {
                gameState.active=false;
                if(gameState.wave===5) {
                    soundManager.playWin(); 
                    const rew = document.getElementById('level-reward'); if(rew) rew.textContent = `獲得獎勵金 💰${250 + gameState.difficultyLevel*50}`;
                    const lvl = document.getElementById('level-screen'); if(lvl) lvl.classList.remove('hidden');
                } else { gameState.gold += 50; updateStatsUI(); }
            }
        }

        function draw() {
            ctx.fillStyle = gameState.factionData ? gameState.factionData.bgColor : '#1a100e';
            ctx.fillRect(0,0,880,700);
            if(!gameState.factionData) return;
            gameState.decorations.forEach(d => { ctx.save(); ctx.translate(d.x,d.y); ctx.rotate(d.rot); ctx.font='20px serif'; ctx.fillText(d.icon,0,0); ctx.restore(); });
            ctx.lineWidth=30; ctx.lineCap='round'; ctx.strokeStyle='rgba(0,0,0,0.1)'; ctx.beginPath();
            gameState.allPaths[0].forEach((p,i) => i===0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y)); ctx.stroke();
            
            const endP = gameState.allPaths[0][gameState.allPaths[0].length-1];
            ctx.font = '36px Arial'; ctx.textAlign='center'; ctx.fillText('\u{1F3F0}', endP.x, endP.y+10);
            
            gameState.towers.forEach(t => t.draw()); gameState.enemies.forEach(e => e.draw());
            gameState.projectiles.forEach(p => { ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,4,0,7); ctx.fill(); });
            
            // Draw Ghost Tower Range
            if(gameState.selectedTowerType!==null) {
                const c = Math.floor(gameState.mouseX/40); const r = Math.floor(gameState.mouseY/40);
                const x = c*40+20; const y = r*40+20;
                const gen = gameState.factionData.generals[gameState.selectedTowerType];
                const baseRange = (ARCHETYPES[gen.base].stats?.range || ARCHETYPES[gen.base].range) * (gen.stats?.range_mult || 1);
                const finalRange = gen.stats?.range || baseRange;
                
                ctx.globalAlpha=0.3; ctx.fillStyle='green'; ctx.fillRect(c*40, r*40, 40, 40); 
                ctx.globalAlpha=0.15; ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(x,y,finalRange,0,7); ctx.fill();
                ctx.globalAlpha=1;
            }
        }

        function actionUpgrade() { if(gameState.selectedPlacedTower) gameState.selectedPlacedTower.upgrade(); }
        function actionSell() {
            if(gameState.selectedPlacedTower) {
                gameState.gold += Math.floor(gameState.selectedPlacedTower.baseCost*0.6);
                gameState.towers = gameState.towers.filter(t => t !== gameState.selectedPlacedTower);
                soundManager.playSell(); deselectAll();
            }
        }

        function getPos(e) {
            const r = canvas.getBoundingClientRect(); const sX = 880/r.width; const sY = 700/r.height;
            const cX = e.touches ? e.touches[0].clientX : e.clientX; const cY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: (cX-r.left)*sX, y: (cY-r.top)*sY };
        }

        function handleIn(e) {
            if(gameState.gameOver || !gameState.factionData) return;
            const p = getPos(e); gameState.mouseX=p.x; gameState.mouseY=p.y;
            const c = Math.floor(p.x/40); const r = Math.floor(p.y/40);
            const clicked = gameState.towers.find(t => t.c===c && t.r===r);
            if (clicked) { selectPlacedTower(clicked); return; }
            if (gameState.selectedTowerType!==null) {
                const g = gameState.factionData.generals[gameState.selectedTowerType];
                if(gameState.gold >= g.cost && !gameState.roadTiles.some(rt => Math.floor(rt.x/40)===c && Math.floor(rt.y/40)===r)) {
                    gameState.gold -= g.cost; gameState.towers.push(new Tower(c, r, gameState.selectedTowerType));
                    soundManager.playBuild(); updateStatsUI();
                }
            } else deselectAll();
        }
        canvas.addEventListener('mousedown', handleIn);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleIn(e); }, {passive:false});
        canvas.addEventListener('mousemove', (e) => { const p=getPos(e); gameState.mouseX=p.x; gameState.mouseY=p.y; });

        function gameLoop() { update(); draw(); if(!gameState.gameOver) requestAnimationFrame(gameLoop); }
        draw();
    </script>
</body>
</html>